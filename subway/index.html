<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Subway Surfers Clone</title>
  <style>
    :root {
      --hud-text: #ffffff;
      --hud-shadow: rgba(0, 0, 0, 0.58);
      --panel-bg: rgba(16, 26, 42, 0.84);
      --panel-stroke: rgba(255, 255, 255, 0.2);
      --accent: #ffd447;
      --danger: #ff5f57;
      --ok: #48e087;
      --coin: #ffcf2d;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: linear-gradient(180deg, #84d7ff 0%, #e9f7ff 52%, #d7ecff 100%);
      font-family: "Trebuchet MS", "Arial Black", "Segoe UI", sans-serif;
      touch-action: none;
    }

    #game-root {
      position: fixed;
      inset: 0;
      overflow: hidden;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    #hud {
      position: fixed;
      inset: 0;
      pointer-events: none;
      color: var(--hud-text);
      text-shadow: 2px 2px 6px var(--hud-shadow);
      z-index: 20;
    }

    #hud.hidden {
      display: none;
    }

    #pause-btn {
      position: absolute;
      left: 14px;
      top: 14px;
      width: 48px;
      height: 48px;
      border-radius: 14px;
      border: 2px solid rgba(255, 255, 255, 0.42);
      background: rgba(19, 34, 52, 0.62);
      color: white;
      font-size: 22px;
      font-weight: 700;
      pointer-events: auto;
      cursor: pointer;
      backdrop-filter: blur(2px);
    }

    #hud-right {
      position: absolute;
      right: 16px;
      top: 14px;
      text-align: right;
    }

    .hud-label {
      font-size: 12px;
      font-weight: 700;
      letter-spacing: 1.1px;
      opacity: 0.9;
    }

    .hud-value {
      font-size: clamp(22px, 3vw, 34px);
      line-height: 1;
      font-weight: 900;
      margin-bottom: 4px;
    }

    #coins-row {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: flex-end;
      font-size: clamp(18px, 2.3vw, 26px);
      font-weight: 900;
      margin-top: 6px;
    }

    #coin-dot {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: radial-gradient(circle at 32% 28%, #fff5bc 0%, #ffd447 45%, #ea9b10 100%);
      box-shadow: 0 0 8px rgba(255, 198, 60, 0.75);
    }

    #distance {
      position: absolute;
      left: 50%;
      top: 18px;
      transform: translateX(-50%);
      font-size: clamp(18px, 2vw, 24px);
      font-weight: 900;
      letter-spacing: 1px;
    }

    #multiplier {
      position: absolute;
      right: 16px;
      top: 120px;
      color: var(--accent);
      font-size: 24px;
      font-weight: 900;
      opacity: 0;
      transition: opacity 180ms ease;
    }

    .overlay {
      position: fixed;
      inset: 0;
      z-index: 30;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(7, 12, 20, 0.52);
      backdrop-filter: blur(2px);
    }

    .overlay.hidden {
      display: none;
    }

    .panel {
      width: min(92vw, 460px);
      padding: 22px 20px;
      border-radius: 22px;
      border: 2px solid var(--panel-stroke);
      background: linear-gradient(180deg, rgba(26, 45, 71, 0.92), rgba(14, 24, 38, 0.92));
      color: white;
      text-align: center;
      box-shadow: 0 16px 36px rgba(0, 0, 0, 0.35);
    }

    .title {
      font-size: clamp(34px, 8.5vw, 56px);
      font-weight: 900;
      line-height: 0.95;
      letter-spacing: 1.5px;
      text-transform: uppercase;
      color: #ffef84;
      text-shadow:
        0 1px 0 #ffc341,
        0 3px 0 #ef8f26,
        0 6px 14px rgba(0, 0, 0, 0.48);
      margin-bottom: 12px;
    }

    .subtitle {
      font-size: 14px;
      opacity: 0.9;
      margin-bottom: 16px;
      line-height: 1.4;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 10px;
      margin-bottom: 16px;
    }

    .stat {
      background: rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      padding: 10px 8px;
      border: 1px solid rgba(255, 255, 255, 0.12);
    }

    .stat .k {
      font-size: 11px;
      letter-spacing: 1px;
      font-weight: 700;
      opacity: 0.9;
    }

    .stat .v {
      font-size: 24px;
      margin-top: 4px;
      font-weight: 900;
    }

    .btn-row {
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
      margin-top: 10px;
    }

    button.ui-btn {
      min-width: 150px;
      min-height: 48px;
      border-radius: 999px;
      border: none;
      font-size: 16px;
      font-weight: 900;
      letter-spacing: 0.8px;
      text-transform: uppercase;
      cursor: pointer;
      padding: 10px 18px;
      color: #08233d;
      background: linear-gradient(180deg, #fff38a, #ffc94f);
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.25);
    }

    button.ui-btn.secondary {
      color: #ffffff;
      background: linear-gradient(180deg, #3f6ea1, #2c5278);
    }

    #controls-hint {
      margin-top: 14px;
      font-size: 12px;
      opacity: 0.85;
      line-height: 1.5;
    }

    #menu-character {
      margin-top: 10px;
      margin-bottom: 4px;
      font-size: 13px;
      font-weight: 800;
      color: #d8ebff;
      letter-spacing: 0.4px;
    }

    #shop-overlay .panel {
      width: min(96vw, 820px);
      max-height: min(90vh, 860px);
      overflow-y: auto;
      text-align: left;
    }

    #shop-meta {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 12px;
      font-size: 13px;
      color: #d6e9ff;
      font-weight: 800;
      letter-spacing: 0.35px;
    }

    #shop-list {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }

    .shop-card {
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: rgba(255, 255, 255, 0.08);
      padding: 10px;
      display: grid;
      gap: 6px;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
    }

    .shop-card.locked {
      opacity: 0.92;
      background: rgba(14, 22, 34, 0.8);
    }

    .shop-name {
      font-size: 15px;
      font-weight: 900;
      color: #f5fbff;
      letter-spacing: 0.4px;
    }

    .shop-price {
      font-size: 12px;
      font-weight: 800;
      color: #ffe280;
      letter-spacing: 0.35px;
    }

    .shop-ability {
      min-height: 28px;
      font-size: 11px;
      color: #d8ecff;
      line-height: 1.25;
      letter-spacing: 0.25px;
      font-weight: 700;
    }

    .shop-preview {
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      height: 36px;
      overflow: hidden;
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 1px;
      background: rgba(255, 255, 255, 0.12);
    }

    .shop-swatch {
      display: block;
      width: 100%;
      height: 100%;
    }

    .shop-action {
      min-width: 0;
      min-height: 42px;
      width: 100%;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.25);
      font-size: 12px;
      font-weight: 900;
      letter-spacing: 0.6px;
      text-transform: uppercase;
      color: #092640;
      background: linear-gradient(180deg, #fff2a0, #ffc95a);
      cursor: pointer;
    }

    .shop-action.secondary {
      color: #ffffff;
      background: linear-gradient(180deg, #3a6da8, #2b4f77);
    }

    .shop-action.selected {
      color: #06271b;
      background: linear-gradient(180deg, #91ffd6, #45d293);
    }

    #touch-hint {
      position: fixed;
      left: 50%;
      bottom: 12px;
      transform: translateX(-50%);
      z-index: 22;
      padding: 8px 12px;
      border-radius: 999px;
      color: white;
      font-size: 12px;
      letter-spacing: 0.6px;
      background: rgba(12, 22, 34, 0.42);
      border: 1px solid rgba(255, 255, 255, 0.24);
      backdrop-filter: blur(2px);
      pointer-events: none;
      opacity: 0;
      transition: opacity 160ms ease;
    }

    #touch-hint.show {
      opacity: 1;
    }

    #flash {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.45), rgba(255, 75, 75, 0.35));
      z-index: 40;
      pointer-events: none;
      opacity: 0;
      transition: opacity 150ms ease;
    }

    #flash.show {
      opacity: 1;
    }

    #cutscene-overlay {
      z-index: 35;
      align-items: stretch;
      justify-content: stretch;
      background: linear-gradient(180deg, rgba(4, 8, 14, 0.15), rgba(5, 9, 14, 0.45));
      pointer-events: none;
    }

    #cutscene-overlay.hidden {
      display: none;
    }

    #cutscene-caption {
      position: absolute;
      left: 50%;
      bottom: 42px;
      transform: translateX(-50%);
      min-width: min(88vw, 560px);
      padding: 12px 16px;
      border-radius: 14px;
      background: rgba(10, 18, 29, 0.68);
      border: 1px solid rgba(255, 255, 255, 0.22);
      color: #ffffff;
      text-align: center;
      font-size: clamp(14px, 2vw, 18px);
      font-weight: 800;
      letter-spacing: 0.7px;
      text-shadow: 0 2px 5px rgba(0, 0, 0, 0.6);
    }

    #cutscene-skip {
      position: absolute;
      right: 14px;
      top: 14px;
      min-width: 80px;
      height: 34px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.36);
      color: #ffffff;
      font-size: 12px;
      font-weight: 800;
      letter-spacing: 0.8px;
      background: rgba(8, 15, 25, 0.62);
      pointer-events: auto;
      cursor: pointer;
    }

    @media (max-width: 700px) {
      .panel {
        padding: 18px 14px;
      }
      .title {
        font-size: min(13vw, 50px);
      }
      button.ui-btn {
        min-width: 128px;
      }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
</head>
<body>
  <div id="game-root"></div>

  <div id="hud" class="hidden">
    <button id="pause-btn" aria-label="Pause">II</button>
    <div id="distance">0m</div>
    <div id="hud-right">
      <div class="hud-label">SCORE</div>
      <div class="hud-value" id="score-value">0</div>
      <div class="hud-label">COINS</div>
      <div id="coins-row"><span id="coin-dot"></span><span id="coins-value">0</span></div>
    </div>
    <div id="multiplier">x2</div>
  </div>

  <div id="menu-overlay" class="overlay">
    <div class="panel">
      <div class="title">Subway<br>Surfers</div>
      <div class="subtitle">
        Swipe or use Arrow Keys / WASD<br>
        Dash, jump, roll, collect power-ups, dodge trains.
      </div>
      <div class="stats-grid">
        <div class="stat">
          <div class="k">HIGH SCORE</div>
          <div class="v" id="menu-best">0</div>
        </div>
        <div class="stat">
          <div class="k">TOTAL COINS</div>
          <div class="v" id="menu-total-coins">0</div>
        </div>
      </div>
      <div class="btn-row">
        <button id="play-btn" class="ui-btn">Runner Mode</button>
        <button id="play-cop-btn" class="ui-btn secondary">Play As Cop</button>
        <button id="shop-btn" class="ui-btn secondary">Shop</button>
      </div>
      <div id="menu-character">Current Character: Jake</div>
      <div id="controls-hint">
        Left/Right: change lanes<br>
        Up/Space: jump &nbsp;|&nbsp; Down: slide &nbsp;|&nbsp; P: pause
      </div>
    </div>
  </div>

  <div id="shop-overlay" class="overlay hidden">
    <div class="panel">
      <div class="title" style="font-size: min(10vw, 44px); margin-bottom: 8px;">Character Shop</div>
      <div class="subtitle" style="margin-bottom: 8px;">Buy characters with coins, then select who you run as.</div>
      <div id="shop-meta">
        <span id="shop-coins">Coins: 0</span>
        <span id="shop-selected">Selected: Jake</span>
      </div>
      <div id="shop-list"></div>
      <div class="btn-row" style="margin-top: 14px;">
        <button id="shop-close-btn" class="ui-btn secondary">Back</button>
      </div>
    </div>
  </div>

  <div id="pause-overlay" class="overlay hidden">
    <div class="panel">
      <div class="title" style="font-size: min(12vw, 42px);">Paused</div>
      <div class="btn-row">
        <button id="resume-btn" class="ui-btn">Resume</button>
        <button id="pause-menu-btn" class="ui-btn secondary">Menu</button>
      </div>
    </div>
  </div>

  <div id="gameover-overlay" class="overlay hidden">
    <div class="panel">
      <div class="title" id="over-title" style="font-size: min(12vw, 42px); color: #ff8680;">Game Over</div>
      <div class="stats-grid">
        <div class="stat">
          <div class="k">SCORE</div>
          <div class="v" id="over-score">0</div>
        </div>
        <div class="stat">
          <div class="k">DISTANCE</div>
          <div class="v" id="over-distance">0m</div>
        </div>
        <div class="stat">
          <div class="k">COINS</div>
          <div class="v" id="over-coins">0</div>
        </div>
        <div class="stat">
          <div class="k">BEST</div>
          <div class="v" id="over-best">0</div>
        </div>
      </div>
      <div id="new-record" style="display:none; color:#ffe46a; font-weight:900; margin-bottom:8px;">NEW HIGH SCORE!</div>
      <div class="btn-row">
        <button id="retry-btn" class="ui-btn">Play Again</button>
        <button id="retry-cop-btn" class="ui-btn secondary">Play As Cop</button>
        <button id="over-menu-btn" class="ui-btn secondary">Menu</button>
      </div>
    </div>
  </div>

  <div id="cutscene-overlay" class="overlay hidden">
    <button id="cutscene-skip" aria-label="Skip Cutscene">SKIP</button>
    <div id="cutscene-caption">Spray painting the train...</div>
  </div>

  <div id="touch-hint">Swipe Left/Right/Up/Down</div>
  <div id="flash"></div>

  <script>
    (() => {
      "use strict";

      // ===== SECTION 1: CONFIGURATION =====
      const CONFIG = {
        lanePositions: [-2.5, 0, 2.5],
        laneSwitchDuration: 0.18,
        jumpDuration: 0.55,
        jumpRise: 0.25,
        jumpHeight: 3.5,
        slideDuration: 0.62,
        slideCooldown: 0.04,
        inputBufferMs: 200,
        baseSpeed: 15,
        maxSpeed: Number.POSITIVE_INFINITY,
        acceleration: 0.5,
        visibleDistance: 140,
        despawnZ: -35,
        playerHitboxStanding: { w: 0.82, h: 1.6, d: 0.72 },
        playerHitboxSliding: { w: 0.82, h: 0.66, d: 0.88 },
        storage: {
          bestScore: "subway_runner_best_score_v1",
          totalCoins: "subway_runner_total_coins_v1",
          unlockedCharacters: "subway_runner_unlocked_characters_v1",
          selectedCharacter: "subway_runner_selected_character_v1"
        }
      };

      const BASE_CHARACTER_SKIN = {
        skin: 0xf4c7a1,
        hoodie: 0x4a90d9,
        hoodieDark: 0x356ea8,
        pants: 0x2c3e50,
        pantsDark: 0x233346,
        shoe: 0xe74c3c,
        shoeDark: 0xad372b,
        hair: 0x5d4e37,
        accent: 0xffd45e,
        cap: 0x1b2d46,
        zipper: 0xdfe7f2,
        drawCord: 0xc7d2de,
        drawTip: 0x9fb3c4,
        lace: 0xf3f4f6,
        kneePad: 0x1b2431
      };

      function buildAbilityFromPrice(price) {
        const ratio = Math.max(0, Math.min(1, price / 12000));
        const speedBonus = Number((ratio * 3.2).toFixed(2));
        const jumpScale = Number((1 + ratio * 0.2).toFixed(3));
        const coinRadius = Number((1 + ratio * 0.95).toFixed(2));
        const scoreMultiplier = Number((1 + ratio * 0.35).toFixed(3));
        let shieldCharges = 0;
        if (price >= 7000) shieldCharges = 1;
        if (price >= 11000) shieldCharges = 2;

        let tierName = "Starter Flow";
        if (price >= 10000) tierName = "Legend Surge";
        else if (price >= 7000) tierName = "Elite Dash";
        else if (price >= 4000) tierName = "Pro Momentum";
        else if (price >= 1800) tierName = "Street Boost";

        const summary = [
          `+${speedBonus.toFixed(2)} speed`,
          `+${Math.round((jumpScale - 1) * 100)}% jump`,
          `x${scoreMultiplier.toFixed(2)} score`
        ];
        if (shieldCharges > 0) summary.push(`${shieldCharges} shield`);
        summary.push(`coin range ${coinRadius.toFixed(2)}m`);

        return {
          tierName,
          speedBonus,
          jumpScale,
          coinRadius,
          scoreMultiplier,
          shieldCharges,
          summary: summary.join(" | ")
        };
      }

      function makeCharacter(id, name, price, skinOverrides = {}) {
        return {
          id,
          name,
          price,
          skin: Object.assign({}, BASE_CHARACTER_SKIN, skinOverrides),
          ability: buildAbilityFromPrice(price)
        };
      }

      const CHARACTER_CATALOG = [
        makeCharacter("jake", "Jake", 0, {}),
        makeCharacter("tricky", "Tricky", 1200, { hoodie: 0xff5ca8, hoodieDark: 0xbc3876, shoe: 0xffffff, shoeDark: 0xbac8d8, hair: 0x2b1d16, cap: 0x6a2f65 }),
        makeCharacter("fresh", "Fresh", 1500, { hoodie: 0x23b4b4, hoodieDark: 0x197b7b, pants: 0x324a66, pantsDark: 0x22354b, shoe: 0x61f2aa, shoeDark: 0x289a66, accent: 0xffe46d }),
        makeCharacter("yutani", "Yutani", 1650, { hoodie: 0x58e672, hoodieDark: 0x2e9f43, pants: 0x2f3552, pantsDark: 0x1e253d, shoe: 0x8f7bff, shoeDark: 0x5b47bb, hair: 0x202020 }),
        makeCharacter("lucy", "Lucy", 1800, { skin: 0xefc09d, hoodie: 0xff8f52, hoodieDark: 0xc96733, pants: 0x303444, pantsDark: 0x222533, shoe: 0xffdd75, shoeDark: 0xba9a48, hair: 0x3e2417 }),
        makeCharacter("frank", "Frank", 1950, { skin: 0xe9c8af, hoodie: 0x6f77ff, hoodieDark: 0x4850be, pants: 0x2b3246, pantsDark: 0x1f2638, shoe: 0xeeeeee, shoeDark: 0x9ea8b9, hair: 0x312923 }),
        makeCharacter("ninja", "Ninja", 2200, { skin: 0xe8bf9f, hoodie: 0x1b1f2a, hoodieDark: 0x10131a, pants: 0x1b1f2a, pantsDark: 0x0f131b, shoe: 0xd84848, shoeDark: 0x8f2c2c, hair: 0x0f0f12, accent: 0xd84848, cap: 0x090b10 }),
        makeCharacter("robot", "Robot", 2400, { skin: 0xc0c8d2, hoodie: 0x8492a5, hoodieDark: 0x5d6c80, pants: 0x596678, pantsDark: 0x424e5f, shoe: 0x67e7ff, shoeDark: 0x2e93a7, hair: 0x7b8798, accent: 0x67e7ff, zipper: 0xf4f7ff }),
        makeCharacter("skater", "Skater", 2600, { hoodie: 0xff6b48, hoodieDark: 0xbf4228, pants: 0x304d67, pantsDark: 0x1f3347, shoe: 0x56d4ff, shoeDark: 0x2f87a8, hair: 0x4f301e, accent: 0x56d4ff }),
        makeCharacter("viper", "Viper", 2800, { skin: 0xdaa882, hoodie: 0x43c63e, hoodieDark: 0x2d8d2a, pants: 0x293a2a, pantsDark: 0x1a261b, shoe: 0xe8ff71, shoeDark: 0x9db041, hair: 0x1f241f, accent: 0xe8ff71 }),
        makeCharacter("aster", "Aster", 3000, { skin: 0xf1cbb2, hoodie: 0xa77cff, hoodieDark: 0x7653be, pants: 0x31325a, pantsDark: 0x21233d, shoe: 0xff81d1, shoeDark: 0xb84f94, hair: 0x372346, accent: 0xff81d1 }),
        makeCharacter("bolt", "Bolt", 3300, { hoodie: 0x22cbff, hoodieDark: 0x1784a6, pants: 0x233b53, pantsDark: 0x16283c, shoe: 0xfff07c, shoeDark: 0xbda74f, hair: 0x2d3238, accent: 0xfff07c }),
        makeCharacter("drift", "Drift", 3600, { skin: 0xd4aa8a, hoodie: 0xff4f6a, hoodieDark: 0xb6334a, pants: 0x2a2f45, pantsDark: 0x1a1f31, shoe: 0x8fe2ff, shoeDark: 0x3a8ca9, hair: 0x2e2a27, accent: 0x8fe2ff }),
        makeCharacter("echo", "Echo", 3900, { skin: 0xe5c8b4, hoodie: 0x4fd7ff, hoodieDark: 0x2e95b8, pants: 0x254056, pantsDark: 0x182a3a, shoe: 0xffffff, shoeDark: 0xa2b0c2, hair: 0x3e2f2b, accent: 0x4fd7ff }),
        makeCharacter("neon", "Neon", 4300, { hoodie: 0xff4fd0, hoodieDark: 0xad2f8f, pants: 0x25253d, pantsDark: 0x181829, shoe: 0x53ffe2, shoeDark: 0x25a38d, hair: 0x281e2a, accent: 0x53ffe2, cap: 0x4e1f55 }),
        makeCharacter("juno", "Juno", 4700, { skin: 0xe7b995, hoodie: 0xf8bb53, hoodieDark: 0xb07f34, pants: 0x314160, pantsDark: 0x223048, shoe: 0x61d6ff, shoeDark: 0x2a7e9f, hair: 0x4e3424 }),
        makeCharacter("flux", "Flux", 5200, { skin: 0xe4bb9d, hoodie: 0x5af78f, hoodieDark: 0x2ba95a, pants: 0x243744, pantsDark: 0x17252e, shoe: 0xf8f9fa, shoeDark: 0x9da7b3, hair: 0x243228, accent: 0x5af78f }),
        makeCharacter("blaze", "Blaze", 5800, { hoodie: 0xff5d34, hoodieDark: 0xb6381f, pants: 0x3a2f2d, pantsDark: 0x251f1f, shoe: 0xffe861, shoeDark: 0xb69b3c, hair: 0x3f2317, accent: 0xffe861 }),
        makeCharacter("titan", "Titan", 6400, { skin: 0xccb59f, hoodie: 0x8f9db0, hoodieDark: 0x5e6a79, pants: 0x2a3341, pantsDark: 0x1d242f, shoe: 0xc6d9ef, shoeDark: 0x6d8298, hair: 0x3b3b3f, accent: 0xc6d9ef }),
        makeCharacter("wave", "Wave", 7100, { skin: 0xf0c5a2, hoodie: 0x3cd5f6, hoodieDark: 0x2490a8, pants: 0x2a4866, pantsDark: 0x1b3044, shoe: 0xffffff, shoeDark: 0xa3b7c5, hair: 0x2e2e35, accent: 0x3cd5f6 }),
        makeCharacter("frost", "Frost", 7900, { skin: 0xf4d5c2, hoodie: 0xd6ecff, hoodieDark: 0x9ab5cd, pants: 0x486384, pantsDark: 0x32475f, shoe: 0x77d5ff, shoeDark: 0x3a8ca8, hair: 0xe9f1ff, accent: 0x77d5ff }),
        makeCharacter("volt", "Volt", 8700, { skin: 0xe0b690, hoodie: 0xd2ff40, hoodieDark: 0x88a920, pants: 0x2e353d, pantsDark: 0x1e232a, shoe: 0x25292f, shoeDark: 0x12161a, hair: 0x2a261f, accent: 0xd2ff40 }),
        makeCharacter("nova", "Nova", 9600, { skin: 0xf2c7ac, hoodie: 0xff7ec8, hoodieDark: 0xb74f8f, pants: 0x3f3d67, pantsDark: 0x2b2a46, shoe: 0xfff2a7, shoeDark: 0xb8a85d, hair: 0x33283e, accent: 0xfff2a7 }),
        makeCharacter("shadow", "Shadow", 10500, { skin: 0xc8a894, hoodie: 0x2e2f34, hoodieDark: 0x1d1e22, pants: 0x202227, pantsDark: 0x131519, shoe: 0x636b79, shoeDark: 0x303742, hair: 0x0f1114, accent: 0x636b79 }),
        makeCharacter("legend", "Legend", 12000, { skin: 0xf0c9a8, hoodie: 0xffd35f, hoodieDark: 0xbd982f, pants: 0x2e4270, pantsDark: 0x1f2d4f, shoe: 0xffffff, shoeDark: 0x9ea8b3, hair: 0x543b28, accent: 0xffffff })
      ];

      const CHARACTER_BY_ID = Object.fromEntries(CHARACTER_CATALOG.map((c) => [c.id, c]));

      const OBSTACLE_DEFS = {
        BARRIER_SMALL: { kind: "jump", w: 2.2, h: 1.0, d: 0.9, color: 0xff6b35, y: 0.5 },
        BARRIER_LARGE: { kind: "jump", w: 2.2, h: 1.45, d: 1.2, color: 0xc0392b, y: 0.725 },
        TRAIN: { kind: "full_block", w: 2.3, h: 3.6, d: 16.0, color: 0x2c3e50, y: 1.8 },
        TRAIN_MOVING: { kind: "full_block", w: 2.3, h: 3.6, d: 16.0, color: 0x3a536f, y: 1.8 },
        OVERHEAD_SIGN: { kind: "slide", w: 7.6, h: 0.5, d: 0.9, color: 0x27ae60, y: 1.72 },
        OVERHEAD_BEAM: { kind: "slide", w: 7.6, h: 0.34, d: 0.9, color: 0x7f8c8d, y: 1.62 },
        ROADBLOCK: { kind: "lane_block", w: 2.2, h: 2.0, d: 1.0, color: 0xe67e22, y: 1.0 },
        ROADBLOCK_DOUBLE: { kind: "lane_block", w: 5.0, h: 2.0, d: 1.0, color: 0xe67e22, y: 1.0 },
        CONE_ROW: { kind: "jump", w: 2.2, h: 0.8, d: 1.15, color: 0xff7b2f, y: 0.4 },
        LOW_PIPE: { kind: "slide", w: 2.24, h: 0.34, d: 1.1, color: 0x6f7d8b, y: 1.3 },
        SIGNAL_POST: { kind: "lane_block", w: 1.25, h: 2.6, d: 0.9, color: 0xf1c40f, y: 1.3 },
        MAINTENANCE_CART: { kind: "jump", w: 2.2, h: 1.15, d: 1.45, color: 0xc06e2f, y: 0.575 }
      };

      // ===== SECTION 2: UTILITIES =====
      const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
      const lerp = (a, b, t) => a + (b - a) * t;
      const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);
      const easeOutQuad = (t) => 1 - (1 - t) * (1 - t);
      const easeInQuad = (t) => t * t;
      const rand = (min, max) => min + Math.random() * (max - min);
      const randInt = (min, max) => Math.floor(rand(min, max + 1));
      const choose = (arr) => arr[Math.floor(Math.random() * arr.length)];
      const formatInt = (v) => Math.floor(v).toLocaleString();

      function weightedChoice(items) {
        let total = 0;
        for (const item of items) total += item.weight;
        let roll = Math.random() * total;
        for (const item of items) {
          roll -= item.weight;
          if (roll <= 0) return item;
        }
        return items[items.length - 1];
      }

      function safeReadInt(key, fallback = 0) {
        try {
          const raw = localStorage.getItem(key);
          if (raw == null) return fallback;
          const n = Number(raw);
          return Number.isFinite(n) ? n : fallback;
        } catch (_err) {
          return fallback;
        }
      }

      function safeWriteInt(key, value) {
        try {
          localStorage.setItem(key, String(value));
        } catch (_err) {}
      }

      function safeReadJSON(key, fallback) {
        try {
          const raw = localStorage.getItem(key);
          if (!raw) return fallback;
          const parsed = JSON.parse(raw);
          return parsed == null ? fallback : parsed;
        } catch (_err) {
          return fallback;
        }
      }

      function safeWriteJSON(key, value) {
        try {
          localStorage.setItem(key, JSON.stringify(value));
        } catch (_err) {}
      }

      function safeReadString(key, fallback = "") {
        try {
          const raw = localStorage.getItem(key);
          return raw == null ? fallback : String(raw);
        } catch (_err) {
          return fallback;
        }
      }

      function safeWriteString(key, value) {
        try {
          localStorage.setItem(key, String(value));
        } catch (_err) {}
      }

      function intersectsAABB(a, b) {
        return (
          Math.abs(a.x - b.x) * 2 < (a.w + b.w) &&
          Math.abs(a.y - b.y) * 2 < (a.h + b.h) &&
          Math.abs(a.z - b.z) * 2 < (a.d + b.d)
        );
      }

      // ===== SECTION 3: INPUT HANDLER =====
      class InputHandler {
        constructor(bufferMs) {
          this.bufferMs = bufferMs;
          this.queue = [];
          this.down = new Set();
          this.touchStart = null;
          this.onKeyDown = this.onKeyDown.bind(this);
          this.onKeyUp = this.onKeyUp.bind(this);
          this.onTouchStart = this.onTouchStart.bind(this);
          this.onTouchEnd = this.onTouchEnd.bind(this);
          this.bind();
        }

        bind() {
          window.addEventListener("keydown", this.onKeyDown);
          window.addEventListener("keyup", this.onKeyUp);
          window.addEventListener("touchstart", this.onTouchStart, { passive: false });
          window.addEventListener("touchend", this.onTouchEnd, { passive: false });
        }

        dispose() {
          window.removeEventListener("keydown", this.onKeyDown);
          window.removeEventListener("keyup", this.onKeyUp);
          window.removeEventListener("touchstart", this.onTouchStart);
          window.removeEventListener("touchend", this.onTouchEnd);
        }

        onKeyDown(event) {
          const code = event.code;
          if (this.down.has(code) || event.repeat) return;
          this.down.add(code);
          const action = this.keyToAction(code);
          if (action) {
            event.preventDefault();
            this.queueAction(action);
          }
        }

        onKeyUp(event) {
          this.down.delete(event.code);
        }

        keyToAction(code) {
          switch (code) {
            case "ArrowLeft":
            case "KeyA":
              return "left";
            case "ArrowRight":
            case "KeyD":
              return "right";
            case "ArrowUp":
            case "KeyW":
            case "Space":
              return "jump";
            case "ArrowDown":
            case "KeyS":
              return "slide";
            case "KeyP":
            case "Escape":
              return "pause";
            default:
              return null;
          }
        }

        onTouchStart(event) {
          if (!event.touches || event.touches.length === 0) return;
          event.preventDefault();
          const t = event.touches[0];
          this.touchStart = {
            x: t.clientX,
            y: t.clientY,
            time: performance.now()
          };
        }

        onTouchEnd(event) {
          if (!this.touchStart || !event.changedTouches || event.changedTouches.length === 0) return;
          event.preventDefault();
          const t = event.changedTouches[0];
          const dx = t.clientX - this.touchStart.x;
          const dy = t.clientY - this.touchStart.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const elapsed = performance.now() - this.touchStart.time;
          this.touchStart = null;

          if (dist < 24 || elapsed > 320) {
            this.queueAction("jump");
            return;
          }
          if (Math.abs(dx) > Math.abs(dy)) {
            this.queueAction(dx > 0 ? "right" : "left");
          } else {
            this.queueAction(dy < 0 ? "jump" : "slide");
          }
        }

        queueAction(action) {
          this.queue.push({ action, time: performance.now() });
          this.cleanup();
        }

        cleanup() {
          const now = performance.now();
          this.queue = this.queue.filter((q) => now - q.time <= this.bufferMs);
        }

        consumeNext() {
          this.cleanup();
          return this.queue.shift()?.action || null;
        }

        clear() {
          this.queue.length = 0;
          this.down.clear();
        }
      }

      // ===== SECTION 4: UI MANAGER =====
      class UIManager {
        constructor() {
          this.hud = document.getElementById("hud");
          this.pauseBtn = document.getElementById("pause-btn");
          this.scoreValue = document.getElementById("score-value");
          this.coinsValue = document.getElementById("coins-value");
          this.distanceValue = document.getElementById("distance");
          this.multiplier = document.getElementById("multiplier");

          this.menuOverlay = document.getElementById("menu-overlay");
          this.pauseOverlay = document.getElementById("pause-overlay");
          this.gameOverOverlay = document.getElementById("gameover-overlay");
          this.cutsceneOverlay = document.getElementById("cutscene-overlay");
          this.cutsceneCaption = document.getElementById("cutscene-caption");
          this.cutsceneSkip = document.getElementById("cutscene-skip");
          this.touchHint = document.getElementById("touch-hint");
          this.flash = document.getElementById("flash");

          this.menuBest = document.getElementById("menu-best");
          this.menuTotalCoins = document.getElementById("menu-total-coins");
          this.menuCharacter = document.getElementById("menu-character");

          this.overScore = document.getElementById("over-score");
          this.overDistance = document.getElementById("over-distance");
          this.overCoins = document.getElementById("over-coins");
          this.overBest = document.getElementById("over-best");
          this.overTitle = document.getElementById("over-title");
          this.newRecord = document.getElementById("new-record");

          this.playBtn = document.getElementById("play-btn");
          this.playCopBtn = document.getElementById("play-cop-btn");
          this.shopBtn = document.getElementById("shop-btn");
          this.resumeBtn = document.getElementById("resume-btn");
          this.pauseMenuBtn = document.getElementById("pause-menu-btn");
          this.retryBtn = document.getElementById("retry-btn");
          this.retryCopBtn = document.getElementById("retry-cop-btn");
          this.overMenuBtn = document.getElementById("over-menu-btn");

          this.shopOverlay = document.getElementById("shop-overlay");
          this.shopCoins = document.getElementById("shop-coins");
          this.shopSelected = document.getElementById("shop-selected");
          this.shopList = document.getElementById("shop-list");
          this.shopCloseBtn = document.getElementById("shop-close-btn");
        }

        showTouchHint(show) {
          this.touchHint.classList.toggle("show", show);
        }

        showMenu(bestScore, totalCoins, selectedName = "Jake") {
          this.menuBest.textContent = formatInt(bestScore);
          this.menuTotalCoins.textContent = formatInt(totalCoins);
          this.menuCharacter.textContent = `Current Character: ${selectedName}`;
          this.hud.classList.add("hidden");
          this.pauseOverlay.classList.add("hidden");
          this.gameOverOverlay.classList.add("hidden");
          this.cutsceneOverlay.classList.add("hidden");
          this.shopOverlay.classList.add("hidden");
          this.menuOverlay.classList.remove("hidden");
        }

        showPlayingHUD() {
          this.menuOverlay.classList.add("hidden");
          this.pauseOverlay.classList.add("hidden");
          this.gameOverOverlay.classList.add("hidden");
          this.cutsceneOverlay.classList.add("hidden");
          this.shopOverlay.classList.add("hidden");
          this.hud.classList.remove("hidden");
        }

        showPaused() {
          this.pauseOverlay.classList.remove("hidden");
        }

        hidePaused() {
          this.pauseOverlay.classList.add("hidden");
        }

        showGameOver(stats) {
          this.hud.classList.add("hidden");
          this.pauseOverlay.classList.add("hidden");
          this.cutsceneOverlay.classList.add("hidden");
          this.shopOverlay.classList.add("hidden");
          this.gameOverOverlay.classList.remove("hidden");
          this.overTitle.textContent = stats.title || "Game Over";
          this.overScore.textContent = formatInt(stats.score);
          this.overDistance.textContent = `${formatInt(stats.distance)}m`;
          this.overCoins.textContent = formatInt(stats.coins);
          this.overBest.textContent = formatInt(stats.best);
          this.newRecord.style.display = stats.newRecord ? "block" : "none";
        }

        updateHUD(score, coins, distance) {
          this.scoreValue.textContent = formatInt(score);
          this.coinsValue.textContent = formatInt(coins);
          this.distanceValue.textContent = `${formatInt(distance)}m`;
        }

        pulseMultiplier(show) {
          this.multiplier.style.opacity = show ? "1" : "0";
        }

        flashCrash() {
          this.flash.classList.add("show");
          setTimeout(() => this.flash.classList.remove("show"), 130);
        }

        showCutscene(text = "Spray painting the train...") {
          this.hud.classList.add("hidden");
          this.pauseOverlay.classList.add("hidden");
          this.gameOverOverlay.classList.add("hidden");
          this.menuOverlay.classList.add("hidden");
          this.shopOverlay.classList.add("hidden");
          this.cutsceneCaption.textContent = text;
          this.cutsceneOverlay.classList.remove("hidden");
        }

        setCutsceneCaption(text) {
          this.cutsceneCaption.textContent = text;
        }

        hideCutscene() {
          this.cutsceneOverlay.classList.add("hidden");
        }

        showShop(totalCoins, selectedName) {
          this.menuOverlay.classList.add("hidden");
          this.pauseOverlay.classList.add("hidden");
          this.gameOverOverlay.classList.add("hidden");
          this.cutsceneOverlay.classList.add("hidden");
          this.hud.classList.add("hidden");
          this.updateShopMeta(totalCoins, selectedName);
          this.shopOverlay.classList.remove("hidden");
        }

        hideShop() {
          this.shopOverlay.classList.add("hidden");
        }

        updateMenuCoins(totalCoins) {
          this.menuTotalCoins.textContent = formatInt(totalCoins);
        }

        updateMenuCharacter(selectedName) {
          this.menuCharacter.textContent = `Current Character: ${selectedName}`;
        }

        updateShopMeta(totalCoins, selectedName) {
          this.shopCoins.textContent = `Coins: ${formatInt(totalCoins)}`;
          this.shopSelected.textContent = `Selected: ${selectedName}`;
        }

        isShopOpen() {
          return !this.shopOverlay.classList.contains("hidden");
        }
      }

      // ===== SECTION 5: AUDIO PLACEHOLDER =====
      class AudioManager {
        constructor() {
          this.muted = false;
          this.unlocked = false;
          this.bgMusic = new Audio("ytmp3free.cc_subway-surfers-main-theme-youtubemp3free.org.mp3");
          this.bgMusic.loop = true;
          this.bgMusic.volume = 0.35;
          this.bgMusic.preload = "auto";

          this.startWhistle = new Audio("ytmp3free.cc_subway-surfers-heuh-whistle-police-man-sound-youtubemp3free.org.mp3");
          this.startWhistle.loop = false;
          this.startWhistle.volume = 0.85;
          this.startWhistle.preload = "auto";

          this.deathSound = new Audio("ytmp3free.cc_subway-surfers-sound-effects-death-youtubemp3free.org.mp3");
          this.deathSound.loop = false;
          this.deathSound.volume = 0.92;
          this.deathSound.preload = "auto";
        }

        unlockAudio() {
          if (this.unlocked || this.muted) return;
          this.unlocked = true;
          const sounds = [this.bgMusic, this.startWhistle, this.deathSound];
          for (const s of sounds) {
            const wasMuted = s.muted;
            s.muted = true;
            const p = s.play();
            if (p && typeof p.then === "function") {
              p.then(() => {
                s.pause();
                s.currentTime = 0;
                s.muted = wasMuted;
              }).catch(() => {
                s.muted = wasMuted;
              });
            } else {
              s.pause();
              s.currentTime = 0;
              s.muted = wasMuted;
            }
          }
        }

        play(name) {
          if (name === "bgMusic") this.playMusic();
          if (name === "startWhistle") this.playStartWhistle();
          if (name === "crash") this.playDeathSound();
        }

        playMusic() {
          if (this.muted) return;
          const p = this.bgMusic.play();
          if (p && typeof p.catch === "function") p.catch(() => {});
        }

        pauseMusic() {
          this.bgMusic.pause();
        }

        playStartWhistle() {
          if (this.muted) return;
          this.startWhistle.currentTime = 0;
          const p = this.startWhistle.play();
          if (p && typeof p.catch === "function") p.catch(() => {});
        }

        playDeathSound() {
          if (this.muted) return;
          this.deathSound.currentTime = 0;
          const p = this.deathSound.play();
          if (p && typeof p.catch === "function") p.catch(() => {});
        }

        stopAll() {
          this.bgMusic.pause();
          this.bgMusic.currentTime = 0;
          this.startWhistle.pause();
          this.startWhistle.currentTime = 0;
          this.deathSound.pause();
          this.deathSound.currentTime = 0;
        }

        mute() {
          this.muted = true;
          this.bgMusic.pause();
          this.startWhistle.pause();
          this.deathSound.pause();
        }
      }

      // ===== SECTION 6: PARTICLE SYSTEM =====
      class ParticleSystem {
        constructor(scene) {
          this.scene = scene;
          this.pool = [];
          this.active = [];
          this.geometry = new THREE.SphereGeometry(0.06, 6, 6);
        }

        createParticle() {
          const material = new THREE.MeshBasicMaterial({
            color: 0xffdd63,
            transparent: true,
            opacity: 1
          });
          const mesh = new THREE.Mesh(this.geometry, material);
          mesh.visible = false;
          this.scene.add(mesh);
          return { mesh, vx: 0, vy: 0, vz: 0, life: 0, ttl: 0 };
        }

        emitCoinBurst(position, count = 10) {
          for (let i = 0; i < count; i++) {
            const p = this.pool.pop() || this.createParticle();
            p.life = 0;
            p.ttl = rand(0.3, 0.55);
            p.vx = rand(-1.8, 1.8);
            p.vy = rand(1.2, 3.3);
            p.vz = rand(-1.2, 1.1);
            p.mesh.position.set(position.x, position.y, position.z);
            p.mesh.material.opacity = 1;
            p.mesh.visible = true;
            this.active.push(p);
          }
        }

        update(dt, worldSpeed) {
          for (let i = this.active.length - 1; i >= 0; i--) {
            const p = this.active[i];
            p.life += dt;
            if (p.life >= p.ttl) {
              p.mesh.visible = false;
              this.pool.push(p);
              this.active.splice(i, 1);
              continue;
            }
            p.vy -= 7.2 * dt;
            p.mesh.position.x += p.vx * dt;
            p.mesh.position.y += p.vy * dt;
            p.mesh.position.z += (p.vz - worldSpeed) * dt;
            p.mesh.material.opacity = 1 - p.life / p.ttl;
          }
        }

        clear() {
          for (const p of this.active) {
            p.mesh.visible = false;
            this.pool.push(p);
          }
          this.active.length = 0;
        }
      }

      // ===== SECTION 7: PLAYER =====
      class Player {
        constructor(scene) {
          this.scene = scene;
          this.group = new THREE.Group();
          this.group.position.set(0, 0, 0);
          scene.add(this.group);

          this.visualRoot = new THREE.Group();
          this.group.add(this.visualRoot);

          this.currentLane = 1;
          this.targetLane = 1;
          this.laneFromX = CONFIG.lanePositions[1];
          this.laneToX = CONFIG.lanePositions[1];
          this.laneElapsed = CONFIG.laneSwitchDuration;
          this.laneSwitchDuration = CONFIG.laneSwitchDuration;
          this.laneLean = 0;
          this.laneVelocity = 0;

          this.isJumping = false;
          this.jumpElapsed = 0;
          this.jumpY = 0;

          this.isSliding = false;
          this.slideElapsed = 0;
          this.slideCooldown = 0;
          this.slideFactor = 0;

          this.runClock = 0;
          this.crashed = false;
          this.crashSpin = 0;
          this.jumpScale = 1;
          this.materials = {};
          this.characterId = "jake";
          this.characterName = "Jake";

          this.buildModel();
          this.setCharacter(CHARACTER_BY_ID.jake);
        }

        buildModel() {
          const skin = this.materials.skin = new THREE.MeshLambertMaterial({ color: 0xf4c7a1 });
          const hoodie = this.materials.hoodie = new THREE.MeshLambertMaterial({ color: 0x4a90d9 });
          const hoodieDark = this.materials.hoodieDark = new THREE.MeshLambertMaterial({ color: 0x356ea8 });
          const pants = this.materials.pants = new THREE.MeshLambertMaterial({ color: 0x2c3e50 });
          const pantsDark = this.materials.pantsDark = new THREE.MeshLambertMaterial({ color: 0x233346 });
          const shoe = this.materials.shoe = new THREE.MeshLambertMaterial({ color: 0xe74c3c });
          const shoeDark = this.materials.shoeDark = new THREE.MeshLambertMaterial({ color: 0xad372b });
          const hair = this.materials.hair = new THREE.MeshLambertMaterial({ color: 0x5d4e37 });

          const torso = new THREE.Mesh(new THREE.CapsuleGeometry(0.24, 0.5, 6, 14), hoodie);
          torso.position.y = 1.1;
          torso.scale.set(1.28, 1.0, 1.02);
          this.visualRoot.add(torso);

          const hoodieBand = new THREE.Mesh(new THREE.CylinderGeometry(0.34, 0.34, 0.1, 14), hoodieDark);
          hoodieBand.position.y = 0.71;
          this.visualRoot.add(hoodieBand);

          const hoodRing = new THREE.Mesh(new THREE.TorusGeometry(0.26, 0.07, 10, 18), hoodieDark);
          hoodRing.position.set(0, 1.45, -0.15);
          hoodRing.rotation.x = Math.PI * 0.52;
          this.visualRoot.add(hoodRing);

          const head = new THREE.Mesh(new THREE.SphereGeometry(0.31, 20, 18), skin);
          head.position.y = 1.72;
          this.visualRoot.add(head);

          const hairCap = new THREE.Mesh(new THREE.SphereGeometry(0.305, 18, 14), hair);
          hairCap.position.y = 1.82;
          hairCap.scale.y = 0.58;
          this.visualRoot.add(hairCap);

          const eyeWhiteMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
          const pupilMat = new THREE.MeshBasicMaterial({ color: 0x1b1b1b });
          const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.035, 8, 8), eyeWhiteMat);
          const eyeR = new THREE.Mesh(new THREE.SphereGeometry(0.035, 8, 8), eyeWhiteMat);
          const pupilL = new THREE.Mesh(new THREE.SphereGeometry(0.015, 7, 7), pupilMat);
          const pupilR = new THREE.Mesh(new THREE.SphereGeometry(0.015, 7, 7), pupilMat);
          eyeL.position.set(-0.09, 1.75, 0.27);
          eyeR.position.set(0.09, 1.75, 0.27);
          pupilL.position.set(-0.09, 1.75, 0.297);
          pupilR.position.set(0.09, 1.75, 0.297);
          this.visualRoot.add(eyeL, eyeR, pupilL, pupilR);

          const nose = new THREE.Mesh(new THREE.SphereGeometry(0.03, 7, 7), skin);
          nose.position.set(0, 1.67, 0.305);
          this.visualRoot.add(nose);

          const backpack = new THREE.Mesh(new THREE.CapsuleGeometry(0.15, 0.35, 5, 9), hoodieDark);
          backpack.position.set(0, 1.04, -0.25);
          backpack.scale.set(1.0, 1.08, 0.72);
          this.visualRoot.add(backpack);

          const pocket = new THREE.Mesh(new THREE.BoxGeometry(0.42, 0.2, 0.09), hoodieDark);
          pocket.position.set(0, 0.92, 0.22);
          this.visualRoot.add(pocket);
          const zipper = new THREE.Mesh(new THREE.BoxGeometry(0.035, 0.7, 0.03), this.materials.zipper = new THREE.MeshLambertMaterial({ color: 0xdfe7f2 }));
          zipper.position.set(0, 1.1, 0.25);
          this.visualRoot.add(zipper);
          const drawCordMat = this.materials.drawCord = new THREE.MeshLambertMaterial({ color: 0xc7d2de });
          const drawCordL = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.012, 0.38, 6), drawCordMat);
          const drawCordR = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.012, 0.38, 6), drawCordMat);
          drawCordL.position.set(-0.06, 1.28, 0.24);
          drawCordR.position.set(0.06, 1.28, 0.24);
          this.visualRoot.add(drawCordL, drawCordR);
          const drawTipL = new THREE.Mesh(new THREE.SphereGeometry(0.018, 7, 6), this.materials.drawTip = new THREE.MeshLambertMaterial({ color: 0x9fb3c4 }));
          const drawTipR = drawTipL.clone();
          drawTipL.position.set(-0.06, 1.1, 0.24);
          drawTipR.position.set(0.06, 1.1, 0.24);
          this.visualRoot.add(drawTipL, drawTipR);
          const capBrim = new THREE.Mesh(new THREE.BoxGeometry(0.24, 0.03, 0.12), this.materials.cap = new THREE.MeshLambertMaterial({ color: 0x1b2d46 }));
          capBrim.position.set(0, 1.83, 0.23);
          this.visualRoot.add(capBrim);

          this.leftArmPivot = new THREE.Group();
          this.rightArmPivot = new THREE.Group();
          this.leftArmPivot.position.set(-0.41, 1.34, 0);
          this.rightArmPivot.position.set(0.41, 1.34, 0);

          const armGeo = new THREE.CapsuleGeometry(0.082, 0.34, 5, 10);
          const handGeo = new THREE.SphereGeometry(0.085, 10, 9);
          const lArm = new THREE.Mesh(armGeo, hoodie);
          const rArm = new THREE.Mesh(armGeo, hoodie);
          lArm.position.y = -0.28;
          rArm.position.y = -0.28;
          const lHand = new THREE.Mesh(handGeo, skin);
          const rHand = new THREE.Mesh(handGeo, skin);
          lHand.position.y = -0.52;
          rHand.position.y = -0.52;
          const lCuff = new THREE.Mesh(new THREE.CylinderGeometry(0.09, 0.09, 0.06, 10), hoodieDark);
          const rCuff = new THREE.Mesh(new THREE.CylinderGeometry(0.09, 0.09, 0.06, 10), hoodieDark);
          lCuff.position.y = -0.44;
          rCuff.position.y = -0.44;
          const lBand = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.045, 0.06), this.materials.accent = new THREE.MeshLambertMaterial({ color: 0xffd45e }));
          const rBand = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.045, 0.06), new THREE.MeshLambertMaterial({ color: 0xffd45e }));
          rBand.material = this.materials.accent;
          lBand.position.set(0, -0.5, 0.09);
          rBand.position.set(0, -0.5, 0.09);
          this.leftArmPivot.add(lArm, lCuff, lHand, lBand);
          this.rightArmPivot.add(rArm, rCuff, rHand, rBand);
          this.visualRoot.add(this.leftArmPivot, this.rightArmPivot);

          this.leftLegPivot = new THREE.Group();
          this.rightLegPivot = new THREE.Group();
          this.leftLegPivot.position.set(-0.17, 0.86, 0.01);
          this.rightLegPivot.position.set(0.17, 0.86, 0.01);

          const thighGeo = new THREE.CapsuleGeometry(0.1, 0.24, 4, 8);
          const shinGeo = new THREE.CapsuleGeometry(0.09, 0.22, 4, 8);

          this.leftThigh = new THREE.Mesh(thighGeo, pants);
          this.rightThigh = new THREE.Mesh(thighGeo, pants);
          this.leftThigh.position.y = -0.22;
          this.rightThigh.position.y = -0.22;
          this.leftLegPivot.add(this.leftThigh);
          this.rightLegPivot.add(this.rightThigh);

          this.leftShinPivot = new THREE.Group();
          this.rightShinPivot = new THREE.Group();
          this.leftShinPivot.position.y = -0.43;
          this.rightShinPivot.position.y = -0.43;

          const lShin = new THREE.Mesh(shinGeo, pantsDark);
          const rShin = new THREE.Mesh(shinGeo, pantsDark);
          lShin.position.y = -0.18;
          rShin.position.y = -0.18;
          this.leftShinPivot.add(lShin);
          this.rightShinPivot.add(rShin);

          const shoeBodyGeo = new THREE.CapsuleGeometry(0.105, 0.2, 4, 7);
          const shoeSoleGeo = new THREE.BoxGeometry(0.26, 0.05, 0.34);
          const lShoe = new THREE.Mesh(shoeBodyGeo, shoe);
          const rShoe = new THREE.Mesh(shoeBodyGeo, shoe);
          lShoe.scale.set(1.12, 0.66, 1.3);
          rShoe.scale.set(1.12, 0.66, 1.3);
          lShoe.position.set(0, -0.37, 0.11);
          rShoe.position.set(0, -0.37, 0.11);
          const lSole = new THREE.Mesh(shoeSoleGeo, shoeDark);
          const rSole = new THREE.Mesh(shoeSoleGeo, shoeDark);
          lSole.position.set(0, -0.42, 0.12);
          rSole.position.set(0, -0.42, 0.12);
          const laceMat = this.materials.lace = new THREE.MeshLambertMaterial({ color: 0xf3f4f6 });
          const lLace = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.012, 0.18), laceMat);
          const rLace = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.012, 0.18), laceMat);
          lLace.position.set(0, -0.35, 0.2);
          rLace.position.set(0, -0.35, 0.2);
          this.leftShinPivot.add(lShoe, lSole);
          this.rightShinPivot.add(rShoe, rSole);
          this.leftShinPivot.add(lLace);
          this.rightShinPivot.add(rLace);

          const kneePadMat = this.materials.kneePad = new THREE.MeshLambertMaterial({ color: 0x1b2431 });
          const kneePadL = new THREE.Mesh(new THREE.SphereGeometry(0.08, 10, 8), kneePadMat);
          const kneePadR = new THREE.Mesh(new THREE.SphereGeometry(0.08, 10, 8), kneePadMat);
          kneePadL.scale.z = 0.62;
          kneePadR.scale.z = 0.62;
          kneePadL.position.set(0, -0.06, 0.09);
          kneePadR.position.set(0, -0.06, 0.09);
          this.leftShinPivot.add(kneePadL);
          this.rightShinPivot.add(kneePadR);

          this.leftLegPivot.add(this.leftShinPivot);
          this.rightLegPivot.add(this.rightShinPivot);
          this.visualRoot.add(this.leftLegPivot, this.rightLegPivot);
        }

        setCharacter(character) {
          const c = character || CHARACTER_BY_ID.jake;
          this.characterId = c.id || "jake";
          this.characterName = c.name || "Jake";
          this.applyCharacterSkin(c.skin || BASE_CHARACTER_SKIN);
        }

        setAbilityModifiers(mods) {
          this.jumpScale = mods && Number.isFinite(mods.jumpScale) ? mods.jumpScale : 1;
        }

        applyCharacterSkin(skinData) {
          const palette = Object.assign({}, BASE_CHARACTER_SKIN, skinData || {});
          const apply = (slot, key) => {
            const m = this.materials[slot];
            if (!m) return;
            m.color.setHex(palette[key]);
            m.needsUpdate = true;
          };

          apply("skin", "skin");
          apply("hoodie", "hoodie");
          apply("hoodieDark", "hoodieDark");
          apply("pants", "pants");
          apply("pantsDark", "pantsDark");
          apply("shoe", "shoe");
          apply("shoeDark", "shoeDark");
          apply("hair", "hair");
          apply("accent", "accent");
          apply("cap", "cap");
          apply("zipper", "zipper");
          apply("drawCord", "drawCord");
          apply("drawTip", "drawTip");
          apply("lace", "lace");
          apply("kneePad", "kneePad");
        }

        reset() {
          this.currentLane = 1;
          this.targetLane = 1;
          this.laneFromX = CONFIG.lanePositions[1];
          this.laneToX = CONFIG.lanePositions[1];
          this.laneElapsed = CONFIG.laneSwitchDuration;
          this.laneSwitchDuration = CONFIG.laneSwitchDuration;
          this.group.position.set(0, 0, 0);
          this.laneLean = 0;
          this.laneVelocity = 0;
          this.isJumping = false;
          this.jumpElapsed = 0;
          this.jumpY = 0;
          this.isSliding = false;
          this.slideElapsed = 0;
          this.slideCooldown = 0;
          this.slideFactor = 0;
          this.runClock = 0;
          this.crashed = false;
          this.crashSpin = 0;
          this.visualRoot.rotation.set(0, 0, 0);
          this.visualRoot.position.set(0, 0, 0);
        }

        queueLane(direction) {
          if (this.crashed) return false;
          const next = clamp(this.targetLane + direction, 0, 2);
          if (next === this.targetLane) return false;
          this.laneFromX = this.group.position.x;
          this.targetLane = next;
          this.laneToX = CONFIG.lanePositions[next];
          this.laneElapsed = 0;
          return true;
        }

        jump() {
          if (this.crashed || this.isJumping || this.isSliding) return false;
          this.isJumping = true;
          this.jumpElapsed = 0;
          return true;
        }

        slide() {
          if (this.crashed || this.isJumping) return false;
          if (this.isSliding) {
            // Allow chaining/refreshing slide so very close duck obstacles stay fair.
            this.slideElapsed = 0;
            return true;
          }
          if (this.slideCooldown > 0) return false;
          this.isSliding = true;
          this.slideElapsed = 0;
          return true;
        }

        crash() {
          this.crashed = true;
          this.crashSpin = rand(-3.8, 3.8);
        }

        getHitbox() {
          const hb = this.isSliding ? CONFIG.playerHitboxSliding : CONFIG.playerHitboxStanding;
          return {
            x: this.group.position.x,
            y: this.jumpY + hb.h * 0.5,
            z: 0,
            w: hb.w,
            h: hb.h,
            d: hb.d
          };
        }

        update(dt, speed, idle = false) {
          const prevX = this.group.position.x;
          const laneDuration = Math.max(0.035, this.laneSwitchDuration || CONFIG.laneSwitchDuration);

          if (this.laneElapsed < laneDuration) {
            this.laneElapsed += dt;
            const t = clamp(this.laneElapsed / laneDuration, 0, 1);
            this.group.position.x = lerp(this.laneFromX, this.laneToX, easeOutCubic(t));
            if (t >= 1) this.currentLane = this.targetLane;
          } else {
            this.group.position.x = this.laneToX;
            this.currentLane = this.targetLane;
          }
          this.laneVelocity = (this.group.position.x - prevX) / Math.max(dt, 0.0001);
          const desiredLean = clamp(-this.laneVelocity * 0.045, -0.27, 0.27);
          this.laneLean = lerp(this.laneLean, desiredLean, Math.min(1, dt * 14));

          if (this.slideCooldown > 0) {
            this.slideCooldown = Math.max(0, this.slideCooldown - dt);
          }

          if (this.isJumping) {
            this.jumpElapsed += dt;
            const t = clamp(this.jumpElapsed / CONFIG.jumpDuration, 0, 1);
            const riseFrac = CONFIG.jumpRise / CONFIG.jumpDuration;
            const jumpHeight = CONFIG.jumpHeight * this.jumpScale;
            if (t <= riseFrac) {
              const u = t / riseFrac;
              this.jumpY = easeOutQuad(u) * jumpHeight;
            } else {
              const u = (t - riseFrac) / (1 - riseFrac);
              this.jumpY = (1 - easeInQuad(u)) * jumpHeight;
            }
            if (t >= 1) {
              this.isJumping = false;
              this.jumpY = 0;
            }
          } else if (!this.crashed) {
            this.jumpY = Math.max(0, this.jumpY - dt * 11);
          }

          if (this.isSliding) {
            this.slideElapsed += dt;
            if (this.slideElapsed >= CONFIG.slideDuration) {
              this.isSliding = false;
              this.slideCooldown = CONFIG.slideCooldown;
            }
          }

          const slideTarget = this.isSliding ? 1 : 0;
          this.slideFactor = lerp(this.slideFactor, slideTarget, Math.min(1, dt * 15));

          const runRate = idle ? 1.4 : clamp(speed / CONFIG.baseSpeed, 0.9, 2.4);
          this.runClock += dt * runRate * (this.crashed ? 0.35 : 5.5);
          const phase = this.runClock;

          if (this.crashed) {
            this.visualRoot.rotation.z += this.crashSpin * dt * 0.2;
            this.visualRoot.rotation.x = lerp(this.visualRoot.rotation.x, -1.0, dt * 8);
            this.visualRoot.position.y = Math.max(0, this.visualRoot.position.y - dt * 6);
            return;
          }

          const swing = Math.sin(phase) * 0.92;
          const kneeL = Math.max(0, -Math.sin(phase)) * 0.7;
          const kneeR = Math.max(0, Math.sin(phase)) * 0.7;
          const armSwing = -swing * 0.75;
          const bob = Math.abs(Math.sin(phase * 2)) * 0.08;
          const jumpPose = this.isJumping ? 1 : 0;

          this.leftLegPivot.rotation.x = swing * (0.88 - 0.35 * jumpPose);
          this.rightLegPivot.rotation.x = -swing * (0.88 - 0.35 * jumpPose);
          this.leftShinPivot.rotation.x = kneeL;
          this.rightShinPivot.rotation.x = kneeR;
          this.leftArmPivot.rotation.x = armSwing + 0.2 * jumpPose;
          this.rightArmPivot.rotation.x = -armSwing + 0.2 * jumpPose;
          this.leftArmPivot.rotation.z = -this.laneLean * 0.7;
          this.rightArmPivot.rotation.z = -this.laneLean * 0.7;

          const torsoLean = -0.14 - this.slideFactor * 0.52 + jumpPose * 0.11;
          this.visualRoot.rotation.x = torsoLean;
          this.visualRoot.rotation.z = this.laneLean;
          this.visualRoot.position.y = this.jumpY + bob - this.slideFactor * 0.52;
        }
      }

      class CopChaser {
        constructor(scene) {
          this.scene = scene;
          this.group = new THREE.Group();
          this.group.visible = false;
          this.scene.add(this.group);

          this.runClock = 0;
          this.catchUp = 0;
          this.isJumping = false;
          this.jumpElapsed = 0;
          this.jumpY = 0;
          this.isSliding = false;
          this.slideElapsed = 0;
          this.slideFactor = 0;
          this.actionCooldown = 0;
          this.currentLane = 1;
          this.targetLane = 1;
          this.laneFromX = CONFIG.lanePositions[1];
          this.laneToX = CONFIG.lanePositions[1];
          this.laneElapsed = CONFIG.laneSwitchDuration;
          this.laneLean = 0;
          this.laneVelocity = 0;
          this.buildModel();
          this.reset();
        }

        buildModel() {
          const skin = new THREE.MeshLambertMaterial({ color: 0xf0c9a9 });
          const uniform = new THREE.MeshLambertMaterial({ color: 0x22354d });
          const uniformLight = new THREE.MeshLambertMaterial({ color: 0x304866 });
          const pants = new THREE.MeshLambertMaterial({ color: 0x1d2939 });
          const shoe = new THREE.MeshLambertMaterial({ color: 0x101317 });
          const badge = new THREE.MeshLambertMaterial({ color: 0xf6c44f });

          const torso = new THREE.Mesh(new THREE.CapsuleGeometry(0.25, 0.55, 6, 12), uniform);
          torso.position.y = 1.12;
          torso.scale.set(1.28, 1.0, 1.02);
          this.group.add(torso);

          const vest = new THREE.Mesh(new THREE.BoxGeometry(0.68, 0.78, 0.2), uniformLight);
          vest.position.set(0, 1.1, 0.08);
          this.group.add(vest);

          const belt = new THREE.Mesh(new THREE.CylinderGeometry(0.34, 0.34, 0.08, 12), new THREE.MeshLambertMaterial({ color: 0x161b24 }));
          belt.position.y = 0.7;
          this.group.add(belt);

          const badgePlate = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.12, 0.03), badge);
          badgePlate.position.set(0.2, 1.3, 0.2);
          this.group.add(badgePlate);

          const radio = new THREE.Mesh(new THREE.BoxGeometry(0.09, 0.18, 0.06), new THREE.MeshLambertMaterial({ color: 0x2d333f }));
          radio.position.set(-0.26, 1.35, 0.17);
          this.group.add(radio);
          const shoulderPatchL = new THREE.Mesh(new THREE.CylinderGeometry(0.065, 0.065, 0.035, 10), new THREE.MeshLambertMaterial({ color: 0xf1c44f }));
          const shoulderPatchR = shoulderPatchL.clone();
          shoulderPatchL.rotation.z = Math.PI * 0.5;
          shoulderPatchR.rotation.z = Math.PI * 0.5;
          shoulderPatchL.position.set(-0.52, 1.34, 0.02);
          shoulderPatchR.position.set(0.52, 1.34, 0.02);
          this.group.add(shoulderPatchL, shoulderPatchR);
          const tie = new THREE.Mesh(new THREE.BoxGeometry(0.075, 0.34, 0.03), new THREE.MeshLambertMaterial({ color: 0x0e1723 }));
          tie.position.set(0, 1.2, 0.21);
          this.group.add(tie);

          const head = new THREE.Mesh(new THREE.SphereGeometry(0.31, 18, 16), skin);
          head.position.y = 1.78;
          this.group.add(head);

          const mustache = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.03, 0.03), new THREE.MeshLambertMaterial({ color: 0x4c3a2d }));
          mustache.position.set(0, 1.67, 0.29);
          this.group.add(mustache);
          const whistleCord = new THREE.Mesh(new THREE.TorusGeometry(0.11, 0.008, 8, 16), new THREE.MeshLambertMaterial({ color: 0xd8dee7 }));
          whistleCord.position.set(0, 1.02, 0.18);
          whistleCord.rotation.x = Math.PI * 0.5;
          this.group.add(whistleCord);
          const whistle = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.03, 0.08), new THREE.MeshLambertMaterial({ color: 0xc8d0dc }));
          whistle.position.set(0, 0.92, 0.22);
          this.group.add(whistle);

          const hatTop = new THREE.Mesh(new THREE.CylinderGeometry(0.27, 0.31, 0.2, 16), uniform);
          hatTop.position.y = 2.06;
          this.group.add(hatTop);
          const hatBand = new THREE.Mesh(new THREE.CylinderGeometry(0.29, 0.29, 0.06, 16), new THREE.MeshLambertMaterial({ color: 0x152237 }));
          hatBand.position.y = 1.99;
          this.group.add(hatBand);
          const hatBrim = new THREE.Mesh(new THREE.CylinderGeometry(0.38, 0.38, 0.035, 16), uniform);
          hatBrim.position.y = 1.95;
          this.group.add(hatBrim);

          this.leftArmPivot = new THREE.Group();
          this.rightArmPivot = new THREE.Group();
          this.leftArmPivot.position.set(-0.42, 1.35, 0);
          this.rightArmPivot.position.set(0.42, 1.35, 0);
          const armGeo = new THREE.CapsuleGeometry(0.085, 0.36, 5, 9);
          const leftArm = new THREE.Mesh(armGeo, uniform);
          const rightArm = new THREE.Mesh(armGeo, uniform);
          leftArm.position.y = -0.29;
          rightArm.position.y = -0.29;
          const lHand = new THREE.Mesh(new THREE.SphereGeometry(0.09, 9, 8), skin);
          const rHand = new THREE.Mesh(new THREE.SphereGeometry(0.09, 9, 8), skin);
          lHand.position.y = -0.54;
          rHand.position.y = -0.54;
          this.leftArmPivot.add(leftArm, lHand);
          this.rightArmPivot.add(rightArm, rHand);
          this.group.add(this.leftArmPivot, this.rightArmPivot);
          const elbowPadMat = new THREE.MeshLambertMaterial({ color: 0x182536 });
          const elbowL = new THREE.Mesh(new THREE.SphereGeometry(0.065, 8, 8), elbowPadMat);
          const elbowR = elbowL.clone();
          elbowL.scale.z = 0.62;
          elbowR.scale.z = 0.62;
          elbowL.position.set(-0.42, 1.06, 0.1);
          elbowR.position.set(0.42, 1.06, 0.1);
          this.group.add(elbowL, elbowR);

          this.leftLegPivot = new THREE.Group();
          this.rightLegPivot = new THREE.Group();
          this.leftLegPivot.position.set(-0.18, 0.86, 0);
          this.rightLegPivot.position.set(0.18, 0.86, 0);
          const thighGeo = new THREE.CapsuleGeometry(0.105, 0.24, 4, 8);
          const shinGeo = new THREE.CapsuleGeometry(0.095, 0.22, 4, 8);
          this.leftThigh = new THREE.Mesh(thighGeo, pants);
          this.rightThigh = new THREE.Mesh(thighGeo, pants);
          this.leftThigh.position.y = -0.22;
          this.rightThigh.position.y = -0.22;
          this.leftLegPivot.add(this.leftThigh);
          this.rightLegPivot.add(this.rightThigh);

          this.leftShinPivot = new THREE.Group();
          this.rightShinPivot = new THREE.Group();
          this.leftShinPivot.position.y = -0.43;
          this.rightShinPivot.position.y = -0.43;
          const leftShin = new THREE.Mesh(shinGeo, pants);
          const rightShin = new THREE.Mesh(shinGeo, pants);
          leftShin.position.y = -0.18;
          rightShin.position.y = -0.18;
          this.leftShinPivot.add(leftShin);
          this.rightShinPivot.add(rightShin);

          const shoeBodyGeo = new THREE.CapsuleGeometry(0.11, 0.2, 4, 7);
          const leftShoe = new THREE.Mesh(shoeBodyGeo, shoe);
          const rightShoe = new THREE.Mesh(shoeBodyGeo, shoe);
          leftShoe.scale.set(1.12, 0.62, 1.28);
          rightShoe.scale.set(1.12, 0.62, 1.28);
          leftShoe.position.set(0, -0.38, 0.11);
          rightShoe.position.set(0, -0.38, 0.11);
          this.leftShinPivot.add(leftShoe);
          this.rightShinPivot.add(rightShoe);

          this.leftLegPivot.add(this.leftShinPivot);
          this.rightLegPivot.add(this.rightShinPivot);
          this.group.add(this.leftLegPivot, this.rightLegPivot);

          const kneeGuardMat = new THREE.MeshLambertMaterial({ color: 0x172131 });
          const kneeL = new THREE.Mesh(new THREE.SphereGeometry(0.075, 8, 8), kneeGuardMat);
          const kneeR = kneeL.clone();
          kneeL.scale.z = 0.65;
          kneeR.scale.z = 0.65;
          kneeL.position.set(-0.18, 0.5, 0.08);
          kneeR.position.set(0.18, 0.5, 0.08);
          this.group.add(kneeL, kneeR);

          const baton = new THREE.Mesh(
            new THREE.CylinderGeometry(0.03, 0.03, 0.48, 10),
            new THREE.MeshLambertMaterial({ color: 0x0f141b })
          );
          baton.position.set(0.34, 0.73, -0.11);
          baton.rotation.z = Math.PI * 0.22;
          this.group.add(baton);
        }

        reset() {
          this.group.position.set(0, 0, -3.9);
          this.group.rotation.set(0, 0, 0);
          this.runClock = 0;
          this.catchUp = 0;
          this.isJumping = false;
          this.jumpElapsed = 0;
          this.jumpY = 0;
          this.isSliding = false;
          this.slideElapsed = 0;
          this.slideFactor = 0;
          this.actionCooldown = 0;
          this.currentLane = 1;
          this.targetLane = 1;
          this.laneFromX = CONFIG.lanePositions[1];
          this.laneToX = CONFIG.lanePositions[1];
          this.laneElapsed = CONFIG.laneSwitchDuration;
          this.laneLean = 0;
          this.laneVelocity = 0;
        }

        resetActionState() {
          this.isJumping = false;
          this.jumpElapsed = 0;
          this.jumpY = 0;
          this.isSliding = false;
          this.slideElapsed = 0;
          this.slideFactor = 0;
          this.actionCooldown = 0;
        }

        queueLane(direction) {
          const next = clamp(this.targetLane + direction, 0, 2);
          if (next === this.targetLane) return false;
          this.laneFromX = this.group.position.x;
          this.targetLane = next;
          this.laneToX = CONFIG.lanePositions[next];
          this.laneElapsed = 0;
          return true;
        }

        jump() {
          return this.tryJump();
        }

        slide() {
          if (this.isSliding) {
            this.slideElapsed = 0;
            return true;
          }
          return this.trySlide();
        }

        getHitbox() {
          const h = this.isSliding ? 0.68 : 1.62;
          const d = this.isSliding ? 0.9 : 0.72;
          return {
            x: this.group.position.x,
            y: this.jumpY + h * 0.5,
            z: 0,
            w: 0.86,
            h,
            d
          };
        }

        tryJump() {
          if (this.isJumping || this.isSliding || this.actionCooldown > 0) return false;
          this.isJumping = true;
          this.jumpElapsed = 0;
          this.actionCooldown = 0.14;
          return true;
        }

        trySlide() {
          if (this.isSliding || this.isJumping || this.actionCooldown > 0) return false;
          this.isSliding = true;
          this.slideElapsed = 0;
          this.actionCooldown = 0.14;
          return true;
        }

        reactToObstacles(obstacles) {
          if (!obstacles || obstacles.length === 0) return;
          if (this.isJumping || this.isSliding || this.actionCooldown > 0) return;

          let candidate = null;
          let bestDist = Infinity;
          for (const o of obstacles) {
            if (!o.collidable || o.airborne) continue;
            if (o.kind !== "jump" && o.kind !== "slide") continue;
            const obstacleFront = o.z - o.d * 0.5;
            const rel = obstacleFront - this.group.position.z;
            if (rel < 0.2 || rel > 6.6) continue;

            const xOverlap = Math.abs(o.x - this.group.position.x) * 2 < (o.w + 0.92);
            if (!xOverlap) continue;

            if (rel < bestDist) {
              bestDist = rel;
              candidate = o;
            }
          }

          if (!candidate) return;
          if (candidate.kind === "jump" && bestDist <= 3.35) this.tryJump();
          if (candidate.kind === "slide" && bestDist <= 3.0) this.trySlide();
        }

        setVisible(visible) {
          this.group.visible = visible;
        }

        updateControlled(dt, speed) {
          const prevX = this.group.position.x;
          if (this.laneElapsed < CONFIG.laneSwitchDuration) {
            this.laneElapsed += dt;
            const t = clamp(this.laneElapsed / CONFIG.laneSwitchDuration, 0, 1);
            this.group.position.x = lerp(this.laneFromX, this.laneToX, easeOutCubic(t));
            if (t >= 1) this.currentLane = this.targetLane;
          } else {
            this.group.position.x = this.laneToX;
            this.currentLane = this.targetLane;
          }
          this.laneVelocity = (this.group.position.x - prevX) / Math.max(dt, 0.0001);
          const desiredLean = clamp(-this.laneVelocity * 0.04, -0.25, 0.25);
          this.laneLean = lerp(this.laneLean, desiredLean, Math.min(1, dt * 12));

          const runScale = clamp(speed / CONFIG.baseSpeed, 0.85, 2.5);
          this.animateRun(dt, runScale);
          this.group.position.z = 0;
          this.group.rotation.y = this.laneLean * -0.24;
        }

        animateRun(dt, speedScale = 1) {
          if (this.actionCooldown > 0) {
            this.actionCooldown = Math.max(0, this.actionCooldown - dt);
          }

          if (this.isJumping) {
            this.jumpElapsed += dt;
            const t = clamp(this.jumpElapsed / 0.54, 0, 1);
            const riseFrac = 0.44;
            if (t <= riseFrac) {
              this.jumpY = easeOutQuad(t / riseFrac) * 2.1;
            } else {
              const u = (t - riseFrac) / (1 - riseFrac);
              this.jumpY = (1 - easeInQuad(u)) * 2.1;
            }
            if (t >= 1) {
              this.isJumping = false;
              this.jumpY = 0;
            }
          } else {
            this.jumpY = Math.max(0, this.jumpY - dt * 8);
          }

          if (this.isSliding) {
            this.slideElapsed += dt;
            if (this.slideElapsed >= 0.5) {
              this.isSliding = false;
            }
          }
          const slideTarget = this.isSliding ? 1 : 0;
          this.slideFactor = lerp(this.slideFactor, slideTarget, Math.min(1, dt * 14));

          this.runClock += dt * speedScale * 6;
          const phase = this.runClock;
          const swing = Math.sin(phase) * 0.82;
          let kneeL = Math.max(0, -Math.sin(phase)) * 0.64;
          let kneeR = Math.max(0, Math.sin(phase)) * 0.64;
          const bob = Math.abs(Math.sin(phase * 2)) * 0.07;
          const jumpPose = this.isJumping ? 1 : 0;

          const legStride = 1 - this.slideFactor * 0.82;
          this.leftLegPivot.rotation.x = swing * 0.88 * legStride;
          this.rightLegPivot.rotation.x = -swing * 0.88 * legStride;
          kneeL = kneeL * legStride + this.slideFactor * 0.45;
          kneeR = kneeR * legStride + this.slideFactor * 0.45;
          this.leftShinPivot.rotation.x = kneeL;
          this.rightShinPivot.rotation.x = kneeR;

          let leftArmX = -swing * 0.7;
          let rightArmX = swing * 0.7;
          if (jumpPose > 0) {
            leftArmX = lerp(leftArmX, -0.32, 0.7);
            rightArmX = lerp(rightArmX, -0.32, 0.7);
          }
          if (this.slideFactor > 0.001) {
            leftArmX = lerp(leftArmX, -1.25, this.slideFactor);
            rightArmX = lerp(rightArmX, -1.25, this.slideFactor);
          }
          this.leftArmPivot.rotation.x = leftArmX;
          this.rightArmPivot.rotation.x = rightArmX;
          this.leftArmPivot.rotation.z = 0;
          this.rightArmPivot.rotation.z = 0;

          this.group.position.y = bob + this.jumpY - this.slideFactor * 0.32;
        }

        updateGameplay(dt, playerX, speed, mode, obstacles = null) {
          const runScale = clamp(speed / CONFIG.baseSpeed, 0.8, 2.4);
          if (mode === "playing") this.reactToObstacles(obstacles);
          this.animateRun(dt, runScale);
          const targetX = playerX * 0.78;
          this.group.position.x = lerp(this.group.position.x, targetX, Math.min(1, dt * 8));

          if (mode === "crashed") {
            this.catchUp = clamp(this.catchUp + dt * 1.6, 0, 1);
          } else {
            this.catchUp = Math.max(0, this.catchUp - dt * 2.4);
          }

          const targetZ = lerp(-3.9, -0.75, this.catchUp);
          this.group.position.z = lerp(this.group.position.z, targetZ, Math.min(1, dt * 5));
          this.group.rotation.y = (playerX - this.group.position.x) * 0.08;
        }
      }

      // ===== SECTION 8: TRACK / ENVIRONMENT =====
      class TrackSystem {
        constructor(scene) {
          this.scene = scene;
          this.segmentLength = 26;
          this.segmentCount = 16;
          this.wallSegments = [];
          this.nearBuildings = [];
          this.midBuildings = [];
          this.farBuildings = [];
          this.groundTexture = this.createGroundTexture();
          this.graffitiTexture = this.createGraffitiTexture();
          this.reasonGraffitiTextures = this.createReasonGraffitiTextures();
          this.windowTexture = this.createBuildingWindowTexture();
          this.buildGround();
          this.buildRails();
          this.buildSegments();
          this.buildParallax();
        }

        finalizeTexture(texture, repeatX = 1, repeatY = 1, wrap = true) {
          texture.wrapS = wrap ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
          texture.wrapT = wrap ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
          texture.repeat.set(repeatX, repeatY);
          texture.minFilter = THREE.LinearMipmapLinearFilter;
          texture.magFilter = THREE.LinearFilter;
          texture.generateMipmaps = true;
          texture.anisotropy = 8;
          texture.colorSpace = THREE.SRGBColorSpace;
          texture.needsUpdate = true;
          return texture;
        }

        createGroundTexture() {
          const c = document.createElement("canvas");
          c.width = 2048;
          c.height = 2048;
          const g = c.getContext("2d");

          const baseGrad = g.createLinearGradient(0, 0, c.width, c.height);
          baseGrad.addColorStop(0, "#9a7c57");
          baseGrad.addColorStop(0.45, "#8a6f4f");
          baseGrad.addColorStop(1, "#6f5a43");
          g.fillStyle = baseGrad;
          g.fillRect(0, 0, c.width, c.height);

          for (let i = 0; i < 38000; i++) {
            const x = Math.random() * c.width;
            const y = Math.random() * c.height;
            const shade = randInt(78, 156);
            g.fillStyle = `rgba(${shade},${Math.max(56, shade - 24)},${Math.max(34, shade - 48)},${rand(0.1, 0.24).toFixed(3)})`;
            const s = rand(1.1, 3.8);
            g.fillRect(x, y, s, s);
          }

          for (let i = 0; i < 120; i++) {
            g.strokeStyle = `rgba(42,36,30,${rand(0.03, 0.08).toFixed(3)})`;
            g.lineWidth = rand(2, 5);
            g.beginPath();
            g.moveTo(rand(0, c.width), rand(0, c.height));
            g.lineTo(rand(0, c.width), rand(0, c.height));
            g.stroke();
          }

          for (let i = 0; i < 45; i++) {
            g.fillStyle = `rgba(26,24,22,${rand(0.02, 0.06).toFixed(3)})`;
            g.beginPath();
            g.ellipse(rand(0, c.width), rand(0, c.height), rand(35, 120), rand(14, 42), rand(0, Math.PI), 0, Math.PI * 2);
            g.fill();
          }

          for (const laneX of [0.28, 0.5, 0.72]) {
            g.strokeStyle = "rgba(255,245,220,0.1)";
            g.lineWidth = 5;
            g.beginPath();
            g.moveTo(c.width * laneX, 0);
            g.lineTo(c.width * laneX, c.height);
            g.stroke();

            g.strokeStyle = "rgba(38,31,27,0.15)";
            g.lineWidth = 2;
            g.beginPath();
            g.moveTo(c.width * laneX + 8, 0);
            g.lineTo(c.width * laneX + 8, c.height);
            g.stroke();
          }

          const texture = new THREE.CanvasTexture(c);
          return this.finalizeTexture(texture, 4, 40, true);
        }

        createGraffitiTexture() {
          const c = document.createElement("canvas");
          c.width = 512;
          c.height = 512;
          const g = c.getContext("2d");

          const wallGrad = g.createLinearGradient(0, 0, c.width, c.height);
          wallGrad.addColorStop(0, "#657895");
          wallGrad.addColorStop(0.55, "#55647f");
          wallGrad.addColorStop(1, "#4a5870");
          g.fillStyle = wallGrad;
          g.fillRect(0, 0, c.width, c.height);

          for (let i = 0; i < 2300; i++) {
            const shade = randInt(95, 165);
            g.fillStyle = `rgba(${shade},${Math.max(72, shade - 28)},${Math.max(58, shade - 35)},${rand(0.03, 0.12).toFixed(3)})`;
            const s = rand(1, 3.2);
            g.fillRect(rand(0, c.width), rand(0, c.height), s, s);
          }

          for (let i = 0; i < 20; i++) {
            g.fillStyle = `rgba(0,0,0,${rand(0.06, 0.18).toFixed(3)})`;
            g.fillRect(0, i * 26 + rand(-4, 4), c.width, rand(1, 3));
          }

          const colors = ["#ff6b6b", "#4ecdc4", "#ffe66d", "#95e1d3", "#f38181", "#aa96da"];
          for (let i = 0; i < 42; i++) {
            const col = choose(colors);
            g.strokeStyle = col;
            g.lineWidth = rand(5, 14);
            g.beginPath();
            g.moveTo(rand(16, 496), rand(18, 494));
            g.quadraticCurveTo(rand(24, 488), rand(24, 488), rand(16, 496), rand(18, 494));
            g.stroke();

            g.fillStyle = `${col}33`;
            g.beginPath();
            g.arc(rand(18, 494), rand(18, 494), rand(8, 22), 0, Math.PI * 2);
            g.fill();
          }

          const texture = new THREE.CanvasTexture(c);
          return this.finalizeTexture(texture, 1, 1, true);
        }

        createReasonGraffitiTextures() {
          const reasons = [
            "DAD: JUST RIDING AROUND MY NEIGHBORHOOD",
            "DAD: NO MAIN ROADS JUST LOCAL STREETS",
            "DAD: SHORT RIDES CLOSE TO HOME",
            "DAD: I WILL BE HOME BEFORE DARK",
            "DAD: HELMET ON EVERY SINGLE RIDE",
            "DAD: PHONE ON + LOCATION SHARED",
            "DAD: GOOD EXERCISE EVERY DAY",
            "DAD: RIDING WITH FRIENDS NEARBY",
            "DAD: QUICK ERRANDS IN OUR AREA",
            "DAD GET LIAM AN E-BIKE FOR THE NEIGHBORHOOD"
          ];
          return reasons.map((text, i) => this.createReasonGraffitiTexture(text, i));
        }

        createReasonGraffitiTexture(text, index) {
          const c = document.createElement("canvas");
          c.width = 1024;
          c.height = 384;
          const g = c.getContext("2d");
          g.clearRect(0, 0, c.width, c.height);

          const palettes = [
            { fill: "#ff5f9d", stroke: "#2ef5ff", glow: "rgba(255,95,157,0.35)" },
            { fill: "#ffe76a", stroke: "#ff6d2a", glow: "rgba(255,231,106,0.3)" },
            { fill: "#9dff8a", stroke: "#2f7cff", glow: "rgba(157,255,138,0.3)" },
            { fill: "#8df2ff", stroke: "#ff5d5d", glow: "rgba(141,242,255,0.3)" },
            { fill: "#ffb0f1", stroke: "#3df5b4", glow: "rgba(255,176,241,0.3)" }
          ];
          const palette = palettes[index % palettes.length];

          for (let i = 0; i < 7; i++) {
            g.fillStyle = palette.glow;
            g.beginPath();
            g.arc(rand(100, 924), rand(70, 314), rand(24, 66), 0, Math.PI * 2);
            g.fill();
          }

          g.fillStyle = "rgba(24,26,36,0.2)";
          g.fillRect(26, 18, c.width - 52, c.height - 36);

          g.textAlign = "center";
          g.textBaseline = "middle";
          g.font = "bold 92px Impact, Arial Black, sans-serif";

          const words = text.split(" ");
          const maxW = c.width - 120;
          const lines = [];
          let line = "";
          for (const word of words) {
            const next = line ? `${line} ${word}` : word;
            if (g.measureText(next).width <= maxW || line.length === 0) {
              line = next;
            } else {
              lines.push(line);
              line = word;
            }
          }
          if (line) lines.push(line);

          const lineHeight = 96;
          const startY = c.height * 0.5 - ((lines.length - 1) * lineHeight) * 0.5;
          for (let i = 0; i < lines.length; i++) {
            g.strokeStyle = palette.stroke;
            g.lineWidth = 12;
            g.strokeText(lines[i], c.width * 0.5, startY + i * lineHeight);
            g.fillStyle = palette.fill;
            g.fillText(lines[i], c.width * 0.5, startY + i * lineHeight);
          }

          g.font = "bold 34px Arial Black, sans-serif";
          g.fillStyle = "rgba(255,255,255,0.92)";
          g.strokeStyle = "rgba(25,30,42,0.9)";
          g.lineWidth = 5;
          g.strokeText("NEIGHBORHOOD RIDES ONLY", c.width * 0.5, c.height - 42);
          g.fillText("NEIGHBORHOOD RIDES ONLY", c.width * 0.5, c.height - 42);

          const t = new THREE.CanvasTexture(c);
          return this.finalizeTexture(t, 1, 1, false);
        }

        pickReasonGraffitiTexture() {
          return choose(this.reasonGraffitiTextures);
        }

        addReasonGraffitiPanels(group, w, h, d, sideHintX, depthBand) {
          const chance = depthBand <= 11 ? 0.92 : depthBand <= 18 ? 0.74 : 0.35;
          if (Math.random() > chance) return;

          const towardTrack = sideHintX < 0 ? 1 : -1;
          const panelW = Math.min(3.9, Math.max(2.2, w * 0.95));
          const panelH = Math.min(1.8, Math.max(0.95, h * 0.23));
          const panelMat = new THREE.MeshLambertMaterial({
            color: 0xffffff,
            map: this.pickReasonGraffitiTexture(),
            transparent: true,
            side: THREE.DoubleSide
          });
          const panel = new THREE.Mesh(new THREE.PlaneGeometry(panelW, panelH), panelMat);
          panel.position.set(towardTrack * (w * 0.5 + 0.06), rand(-h * 0.08, h * 0.24), rand(-d * 0.18, d * 0.18));
          panel.rotation.y = towardTrack > 0 ? Math.PI * 0.5 : -Math.PI * 0.5;
          panel.rotation.z = rand(-0.08, 0.08);
          panel.userData.isReasonPanel = true;
          panel.userData.baseY = panel.position.y;
          group.add(panel);

          const tagChance = depthBand <= 18 ? 0.52 : 0.24;
          if (Math.random() < tagChance) {
            const tag = new THREE.Mesh(
              new THREE.PlaneGeometry(panelW * 0.46, panelH * 0.46),
              new THREE.MeshLambertMaterial({
                color: 0xffffff,
                map: this.pickReasonGraffitiTexture(),
                transparent: true,
                side: THREE.DoubleSide
              })
            );
            tag.position.set(
              towardTrack * (w * 0.5 + 0.062),
              panel.position.y - panelH * 0.55,
              panel.position.z + rand(-0.9, 0.9)
            );
            tag.rotation.y = panel.rotation.y;
            tag.rotation.z = rand(-0.15, 0.15);
            tag.userData.isReasonPanel = true;
            tag.userData.baseY = tag.position.y;
            group.add(tag);
          }
        }

        refreshReasonGraffitiPanels(group) {
          for (const child of group.children) {
            if (!child.userData || !child.userData.isReasonPanel) continue;
            if (child.material && child.material.map) {
              child.material.map = this.pickReasonGraffitiTexture();
              child.material.needsUpdate = true;
            }
            child.rotation.z = rand(-0.14, 0.14);
            child.position.y = (child.userData.baseY || child.position.y) + rand(-0.08, 0.08);
          }
        }

        createBuildingWindowTexture() {
          const c = document.createElement("canvas");
          c.width = 512;
          c.height = 1024;
          const g = c.getContext("2d");

          const bg = g.createLinearGradient(0, 0, 0, c.height);
          bg.addColorStop(0, "#2f3948");
          bg.addColorStop(1, "#222a36");
          g.fillStyle = bg;
          g.fillRect(0, 0, c.width, c.height);

          for (let i = 0; i < 26; i++) {
            g.fillStyle = `rgba(255,255,255,${rand(0.012, 0.04).toFixed(3)})`;
            g.fillRect(0, rand(0, c.height), c.width, rand(1, 2.2));
          }

          const cellW = 52;
          const cellH = 62;
          for (let y = 14; y < c.height - 10; y += cellH) {
            for (let x = 10; x < c.width - 10; x += cellW) {
              const lit = Math.random() > 0.48;
              const warm = Math.random() > 0.52;
              g.fillStyle = lit
                ? warm ? "rgba(255,227,152,0.86)" : "rgba(177,221,255,0.83)"
                : "rgba(66,85,116,0.66)";
              g.fillRect(x, y, 32, 42);

              g.fillStyle = "rgba(21,28,40,0.45)";
              g.fillRect(x + 15, y, 2, 42);
              g.fillRect(x, y + 20, 32, 2);

              g.strokeStyle = "rgba(12,18,28,0.34)";
              g.lineWidth = 2;
              g.strokeRect(x - 1, y - 1, 34, 44);
            }
          }
          const texture = new THREE.CanvasTexture(c);
          return this.finalizeTexture(texture, 1, 1, true);
        }

        buildGround() {
          const geometry = new THREE.PlaneGeometry(38, 900);
          const material = new THREE.MeshLambertMaterial({
            color: 0xffffff,
            map: this.groundTexture
          });
          this.ground = new THREE.Mesh(geometry, material);
          this.ground.rotation.x = -Math.PI * 0.5;
          this.ground.position.z = 320;
          this.scene.add(this.ground);
        }

        buildRails() {
          const railMat = new THREE.MeshLambertMaterial({ color: 0x708090 });
          const railGeo = new THREE.BoxGeometry(0.08, 0.08, 900);
          this.rails = [];
          for (const lane of CONFIG.lanePositions) {
            for (const offset of [-0.44, 0.44]) {
              const rail = new THREE.Mesh(railGeo, railMat);
              rail.position.set(lane + offset, 0.05, 320);
              this.scene.add(rail);
              this.rails.push(rail);
            }
          }
        }

        randomWallColor() {
          return choose([0xe74c3c, 0x3498db, 0x2ecc71, 0xf39c12, 0x9b59b6]);
        }

        makeWallSegment(z) {
          const group = new THREE.Group();
          const wallGeo = new THREE.BoxGeometry(1, 4.2, this.segmentLength);
          const wallLeft = new THREE.Mesh(
            wallGeo,
            new THREE.MeshLambertMaterial({
              color: this.randomWallColor(),
              map: this.graffitiTexture
            })
          );
          const wallRight = new THREE.Mesh(
            wallGeo,
            new THREE.MeshLambertMaterial({
              color: this.randomWallColor(),
              map: this.graffitiTexture
            })
          );
          wallLeft.position.set(-6.1, 2.1, 0);
          wallRight.position.set(6.1, 2.1, 0);
          group.add(wallLeft, wallRight);

          const fenceGeo = new THREE.BoxGeometry(0.14, 2.5, this.segmentLength);
          const fenceMat = new THREE.MeshLambertMaterial({ color: 0x5f6e7c });
          const fenceLeft = new THREE.Mesh(fenceGeo, fenceMat);
          const fenceRight = new THREE.Mesh(fenceGeo, fenceMat);
          fenceLeft.position.set(-4.9, 1.25, 0);
          fenceRight.position.set(4.9, 1.25, 0);
          group.add(fenceLeft, fenceRight);

          const pipeMat = new THREE.MeshLambertMaterial({ color: 0x6f7f90 });
          const pipeL = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, this.segmentLength, 10), pipeMat);
          const pipeR = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, this.segmentLength, 10), pipeMat);
          pipeL.rotation.x = Math.PI * 0.5;
          pipeR.rotation.x = Math.PI * 0.5;
          pipeL.position.set(-5.45, 3.45, 0);
          pipeR.position.set(5.45, 3.45, 0);
          group.add(pipeL, pipeR);

          for (let zLocal = -this.segmentLength * 0.42; zLocal <= this.segmentLength * 0.42; zLocal += 3.4) {
            const supportL = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.82, 0.14), new THREE.MeshLambertMaterial({ color: 0x586573 }));
            const supportR = supportL.clone();
            supportL.position.set(-5.42, 2.98, zLocal);
            supportR.position.set(5.42, 2.98, zLocal);
            group.add(supportL, supportR);
          }

          const panelMat = new THREE.MeshLambertMaterial({
            color: 0xffffff,
            map: this.pickReasonGraffitiTexture(),
            transparent: true,
            opacity: 0.85,
            side: THREE.DoubleSide
          });
          const panelLeft = new THREE.Mesh(new THREE.PlaneGeometry(1.7, 0.95), panelMat);
          const panelRight = new THREE.Mesh(new THREE.PlaneGeometry(1.7, 0.95), panelMat.clone());
          panelLeft.position.set(-5.55, 2.15, rand(-this.segmentLength * 0.3, this.segmentLength * 0.3));
          panelRight.position.set(5.55, 2.15, rand(-this.segmentLength * 0.3, this.segmentLength * 0.3));
          panelLeft.rotation.y = Math.PI * 0.5;
          panelRight.rotation.y = -Math.PI * 0.5;
          panelLeft.userData.isReasonPanel = true;
          panelRight.userData.isReasonPanel = true;
          panelLeft.userData.baseY = panelLeft.position.y;
          panelRight.userData.baseY = panelRight.position.y;
          group.add(panelLeft, panelRight);

          group.position.z = z;
          this.scene.add(group);
          return group;
        }

        makeBuilding(depth, baseX, widthRange, heightRange, z) {
          const w = rand(widthRange[0], widthRange[1]);
          const h = rand(heightRange[0], heightRange[1]);
          const d = rand(4, 9);
          const geo = new THREE.BoxGeometry(w, h, d);
          const baseColor = new THREE.Color().setHSL(rand(0.53, 0.67), rand(0.22, 0.45), rand(0.28, 0.5));
          const sideMat = new THREE.MeshLambertMaterial({
            color: baseColor,
            map: this.windowTexture
          });
          const roofMat = new THREE.MeshLambertMaterial({ color: baseColor.clone().multiplyScalar(0.62) });
          const mats = [sideMat, sideMat, roofMat, roofMat, sideMat, sideMat];
          const mesh = new THREE.Mesh(geo, mats);

          const group = new THREE.Group();
          group.add(mesh);
          group.position.set(baseX + rand(-depth * 0.2, depth * 0.2), h * 0.5, z + rand(-10, 10));

          const roofProps = new THREE.Group();
          if (Math.random() < 0.74) {
            const ac = new THREE.Mesh(
              new THREE.BoxGeometry(Math.min(1.2, w * 0.45), 0.28, Math.min(1.6, d * 0.35)),
              new THREE.MeshLambertMaterial({ color: 0x616d79 })
            );
            ac.position.set(rand(-w * 0.2, w * 0.2), h * 0.5 + 0.14, rand(-d * 0.2, d * 0.2));
            roofProps.add(ac);
          }
          if (Math.random() < 0.4) {
            const tank = new THREE.Mesh(
              new THREE.CylinderGeometry(0.25, 0.25, 0.42, 12),
              new THREE.MeshLambertMaterial({ color: 0x4d5a67 })
            );
            tank.position.set(rand(-w * 0.22, w * 0.22), h * 0.5 + 0.28, rand(-d * 0.22, d * 0.22));
            roofProps.add(tank);
          }
          group.add(roofProps);

          this.addReasonGraffitiPanels(group, w, h, d, baseX, depth);

          this.scene.add(group);
          return group;
        }

        buildSegments() {
          for (let i = 0; i < this.segmentCount; i++) {
            const z = i * this.segmentLength;
            this.wallSegments.push(this.makeWallSegment(z));
          }

          this.tieGroup = new THREE.Group();
          this.scene.add(this.tieGroup);
          const tieGeo = new THREE.BoxGeometry(8.2, 0.12, 0.34);
          const tieMat = new THREE.MeshLambertMaterial({ color: 0x654321 });
          this.ties = [];
          for (let z = -20; z <= 420; z += 1.9) {
            const tie = new THREE.Mesh(tieGeo, tieMat);
            tie.position.set(0, 0.03, z);
            this.tieGroup.add(tie);
            this.ties.push(tie);
          }
        }

        buildParallax() {
          for (let i = 0; i < 26; i++) {
            this.nearBuildings.push(this.makeBuilding(11, i % 2 === 0 ? -12 : 12, [2.3, 4.4], [5, 9], i * 16));
          }
          for (let i = 0; i < 22; i++) {
            this.midBuildings.push(this.makeBuilding(18, i % 2 === 0 ? -23 : 23, [4, 7], [8, 14], i * 24));
          }
          for (let i = 0; i < 20; i++) {
            this.farBuildings.push(this.makeBuilding(30, i % 2 === 0 ? -34 : 34, [7, 12], [12, 24], i * 30));
          }
        }

        recycleArray(items, speedFactor, dt, minZ, span) {
          const dz = speedFactor * dt;
          for (const item of items) {
            item.position.z -= dz;
            if (item.position.z < minZ) {
              item.position.z += span;
              this.refreshReasonGraffitiPanels(item);
            }
          }
        }

        update(dt, speed) {
          this.groundTexture.offset.y -= speed * dt * 0.07;

          const span = this.segmentLength * this.segmentCount;
          for (const seg of this.wallSegments) {
            seg.position.z -= speed * dt;
            if (seg.position.z < -this.segmentLength) {
              seg.position.z += span;
              for (const child of seg.children) {
                if (child.userData && child.userData.isReasonPanel) continue;
                if (child.material && child.material.color) {
                  child.material.color.setHex(this.randomWallColor());
                }
              }
              this.refreshReasonGraffitiPanels(seg);
            }
          }

          for (const tie of this.ties) {
            tie.position.z -= speed * dt;
            if (tie.position.z < -30) tie.position.z += 450;
          }

          this.recycleArray(this.nearBuildings, speed * 0.72, dt, -45, 420);
          this.recycleArray(this.midBuildings, speed * 0.45, dt, -65, 560);
          this.recycleArray(this.farBuildings, speed * 0.2, dt, -90, 700);
        }
      }

      // ===== SECTION 9: COINS =====
      class CoinManager {
        constructor(scene) {
          this.scene = scene;
          this.active = [];
          this.pool = [];
          this.geometry = new THREE.CylinderGeometry(0.28, 0.28, 0.08, 18);
          this.material = new THREE.MeshLambertMaterial({
            color: 0xffd700,
            emissive: 0x5f3800,
            emissiveIntensity: 0.3
          });
          this.outlineMat = new THREE.MeshLambertMaterial({ color: 0xffa500 });
        }

        createCoin() {
          const group = new THREE.Group();
          const body = new THREE.Mesh(this.geometry, this.material);
          body.rotation.z = Math.PI * 0.5;
          const rim = new THREE.Mesh(new THREE.TorusGeometry(0.26, 0.03, 12, 24), this.outlineMat);
          rim.rotation.y = Math.PI * 0.5;

          const inner = new THREE.Mesh(
            new THREE.CylinderGeometry(0.18, 0.18, 0.09, 14),
            new THREE.MeshLambertMaterial({ color: 0xffec95, emissive: 0x7a5200, emissiveIntensity: 0.18 })
          );
          inner.rotation.z = Math.PI * 0.5;

          const starShape = new THREE.Shape();
          const points = 5;
          const outerR = 0.11;
          const innerR = 0.05;
          for (let i = 0; i < points * 2; i++) {
            const r = i % 2 === 0 ? outerR : innerR;
            const a = (i / (points * 2)) * Math.PI * 2 - Math.PI * 0.5;
            const x = Math.cos(a) * r;
            const y = Math.sin(a) * r;
            if (i === 0) starShape.moveTo(x, y);
            else starShape.lineTo(x, y);
          }
          starShape.closePath();
          const starGeo = new THREE.ShapeGeometry(starShape);
          const starMat = new THREE.MeshLambertMaterial({ color: 0xffa200, emissive: 0x6b3a00, emissiveIntensity: 0.22 });
          const starL = new THREE.Mesh(starGeo, starMat);
          const starR = new THREE.Mesh(starGeo, starMat);
          starL.position.set(0.045, 0, 0);
          starR.position.set(-0.045, 0, 0);
          starL.rotation.y = Math.PI * 0.5;
          starR.rotation.y = -Math.PI * 0.5;

          const sparkleMat = new THREE.MeshBasicMaterial({ color: 0xfff7cf, transparent: true, opacity: 0.75 });
          const sparkleA = new THREE.Mesh(new THREE.PlaneGeometry(0.08, 0.28), sparkleMat);
          const sparkleB = new THREE.Mesh(new THREE.PlaneGeometry(0.28, 0.08), sparkleMat);
          sparkleA.position.set(0, 0.18, 0);
          sparkleB.position.set(0, 0.18, 0);
          sparkleA.rotation.y = Math.PI * 0.5;
          sparkleB.rotation.y = Math.PI * 0.5;

          group.add(body, rim, inner, starL, starR, sparkleA, sparkleB);
          group.visible = false;
          this.scene.add(group);
          return { mesh: group, lane: 1, z: 0, baseY: 1, phase: 0, attracting: false };
        }

        acquire() {
          return this.pool.pop() || this.createCoin();
        }

        release(coin) {
          coin.mesh.visible = false;
          coin.attracting = false;
          this.pool.push(coin);
        }

        spawnCoin(x, y, z) {
          const c = this.acquire();
          c.lane = 1;
          c.z = z;
          c.baseY = y;
          c.phase = rand(0, Math.PI * 2);
          c.mesh.position.set(x, y, z);
          c.mesh.rotation.set(0, rand(0, Math.PI * 2), 0);
          c.mesh.visible = true;
          this.active.push(c);
        }

        spawnLine(lane, zStart, count = 6, spacing = 2.1, y = 1.1) {
          const x = CONFIG.lanePositions[lane];
          for (let i = 0; i < count; i++) {
            this.spawnCoin(x, y, zStart + i * spacing);
          }
        }

        spawnDiagonal(zStart, count = 7, spacing = 2.2) {
          let lane = randInt(0, 2);
          let dir = Math.random() < 0.5 ? 1 : -1;
          for (let i = 0; i < count; i++) {
            lane = clamp(lane, 0, 2);
            this.spawnCoin(CONFIG.lanePositions[lane], 1.1, zStart + i * spacing);
            lane += dir;
            if (lane <= 0 || lane >= 2) dir *= -1;
          }
        }

        spawnArc(lane, zStart, count = 7, spacing = 2.0) {
          const x = CONFIG.lanePositions[lane];
          const mid = (count - 1) / 2;
          for (let i = 0; i < count; i++) {
            const t = (i - mid) / Math.max(mid, 1);
            const y = 1.0 + (1 - t * t) * 1.6;
            this.spawnCoin(x, y, zStart + i * spacing);
          }
        }

        update(dt, speed, time) {
          for (let i = this.active.length - 1; i >= 0; i--) {
            const c = this.active[i];
            c.z -= speed * dt;
            c.mesh.position.z = c.z;
            c.mesh.position.y = c.baseY + Math.sin(time * 6 + c.phase) * 0.1;
            c.mesh.rotation.y += dt * 6.2;
            if (c.z < CONFIG.despawnZ) {
              this.release(c);
              this.active.splice(i, 1);
            }
          }
        }

        removeAt(index) {
          const coin = this.active[index];
          if (!coin) return null;
          this.release(coin);
          this.active.splice(index, 1);
          return coin;
        }

        clear() {
          for (let i = this.active.length - 1; i >= 0; i--) {
            this.release(this.active[i]);
          }
          this.active.length = 0;
        }
      }

      // ===== SECTION 10: OBSTACLE MANAGER =====
      class ObstacleManager {
        constructor(scene, coinManager) {
          this.scene = scene;
          this.coinManager = coinManager;
          this.active = [];
          this.pools = {};
          this.spawnCursor = 20;
          this.patterns = this.buildPatterns();
          this.graffitiTexture = this.createGraffitiTexture();
          this.hazardTexture = this.createHazardTexture();
          this.crateTexture = this.createCrateTexture();
          this.trainBodyTexture = this.createTrainBodyTexture();
          this.trainWindowTexture = this.createTrainWindowTexture();
          this.pipeTexture = this.createPipeTexture();
        }

        finalizeTexture(texture, repeatX = 1, repeatY = 1, wrap = true) {
          texture.wrapS = wrap ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
          texture.wrapT = wrap ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
          texture.repeat.set(repeatX, repeatY);
          texture.minFilter = THREE.LinearMipmapLinearFilter;
          texture.magFilter = THREE.LinearFilter;
          texture.generateMipmaps = true;
          texture.anisotropy = 8;
          texture.colorSpace = THREE.SRGBColorSpace;
          texture.needsUpdate = true;
          return texture;
        }

        createGraffitiTexture() {
          const c = document.createElement("canvas");
          c.width = 512;
          c.height = 256;
          const g = c.getContext("2d");

          const bg = g.createLinearGradient(0, 0, c.width, c.height);
          bg.addColorStop(0, "#344862");
          bg.addColorStop(1, "#27364a");
          g.fillStyle = bg;
          g.fillRect(0, 0, c.width, c.height);

          for (let i = 0; i < 26; i++) {
            g.strokeStyle = choose(["#ff6b6b", "#4ecdc4", "#ffe66d", "#95e1d3"]);
            g.lineWidth = rand(4, 10);
            g.beginPath();
            g.moveTo(rand(10, 502), rand(10, 246));
            g.quadraticCurveTo(rand(10, 502), rand(10, 246), rand(10, 502), rand(10, 246));
            g.stroke();
          }

          for (let i = 0; i < 1300; i++) {
            const shade = randInt(80, 170);
            g.fillStyle = `rgba(${shade},${Math.max(55, shade - 20)},${Math.max(48, shade - 34)},${rand(0.04, 0.18).toFixed(3)})`;
            g.fillRect(rand(0, c.width), rand(0, c.height), rand(1, 3), rand(1, 3));
          }

          const t = new THREE.CanvasTexture(c);
          return this.finalizeTexture(t, 1, 1, true);
        }

        createHazardTexture() {
          const c = document.createElement("canvas");
          c.width = 512;
          c.height = 256;
          const g = c.getContext("2d");

          const bg = g.createLinearGradient(0, 0, 0, c.height);
          bg.addColorStop(0, "#2d333a");
          bg.addColorStop(1, "#1e242a");
          g.fillStyle = bg;
          g.fillRect(0, 0, c.width, c.height);

          for (let x = -120; x < c.width + 120; x += 74) {
            g.save();
            g.translate(x, 0);
            g.rotate(-0.62);
            g.fillStyle = "#ffd044";
            g.fillRect(0, -c.height, 34, c.height * 3);
            g.fillStyle = "rgba(99,74,17,0.22)";
            g.fillRect(21, -c.height, 7, c.height * 3);
            g.restore();
          }

          for (let i = 0; i < 280; i++) {
            g.fillStyle = `rgba(255,255,255,${rand(0.015, 0.06).toFixed(3)})`;
            g.fillRect(rand(0, c.width), rand(0, c.height), rand(1, 2.6), rand(1, 2.6));
          }

          for (let i = 0; i < 16; i++) {
            g.fillStyle = "rgba(24,28,32,0.38)";
            g.fillRect(0, i * 16 + rand(-2, 2), c.width, 3);
          }

          const t = new THREE.CanvasTexture(c);
          return this.finalizeTexture(t, 1, 1, true);
        }

        createCrateTexture() {
          const c = document.createElement("canvas");
          c.width = 512;
          c.height = 512;
          const g = c.getContext("2d");

          const wood = g.createLinearGradient(0, 0, c.width, c.height);
          wood.addColorStop(0, "#a26a3a");
          wood.addColorStop(0.5, "#8e5931");
          wood.addColorStop(1, "#784a2a");
          g.fillStyle = wood;
          g.fillRect(0, 0, c.width, c.height);

          g.strokeStyle = "rgba(62,35,16,0.72)";
          g.lineWidth = 14;
          g.strokeRect(22, 22, c.width - 44, c.height - 44);
          g.lineWidth = 10;
          g.beginPath();
          g.moveTo(36, 36);
          g.lineTo(c.width - 36, c.height - 36);
          g.moveTo(c.width - 36, 36);
          g.lineTo(36, c.height - 36);
          g.stroke();

          for (let i = 0; i < 70; i++) {
            g.strokeStyle = `rgba(64,34,14,${rand(0.08, 0.22).toFixed(3)})`;
            g.lineWidth = rand(1.2, 2.8);
            g.beginPath();
            const y = rand(0, c.height);
            g.moveTo(0, y);
            g.bezierCurveTo(rand(120, 220), y + rand(-8, 8), rand(280, 390), y + rand(-8, 8), c.width, y + rand(-7, 7));
            g.stroke();
          }

          for (let i = 0; i < 5000; i++) {
            const x = Math.random() * c.width;
            const y = Math.random() * c.height;
            const s = randInt(95, 145);
            g.fillStyle = `rgba(${s},${Math.max(40, s - 28)},${Math.max(18, s - 58)},${rand(0.05, 0.18).toFixed(3)})`;
            g.fillRect(x, y, rand(1, 3), rand(1, 3));
          }

          for (const p of [
            [32, 32], [c.width - 32, 32], [32, c.height - 32], [c.width - 32, c.height - 32],
            [c.width * 0.5, 32], [c.width * 0.5, c.height - 32], [32, c.height * 0.5], [c.width - 32, c.height * 0.5]
          ]) {
            g.fillStyle = "#2f2620";
            g.beginPath();
            g.arc(p[0], p[1], 6, 0, Math.PI * 2);
            g.fill();
            g.fillStyle = "rgba(255,255,255,0.18)";
            g.beginPath();
            g.arc(p[0] - 1.5, p[1] - 1.5, 2.2, 0, Math.PI * 2);
            g.fill();
          }

          const t = new THREE.CanvasTexture(c);
          return this.finalizeTexture(t, 1, 1, true);
        }

        createTrainBodyTexture() {
          const c = document.createElement("canvas");
          c.width = 1024;
          c.height = 256;
          const g = c.getContext("2d");

          const base = g.createLinearGradient(0, 0, 0, c.height);
          base.addColorStop(0, "#3f5f86");
          base.addColorStop(0.5, "#274a74");
          base.addColorStop(1, "#1e3555");
          g.fillStyle = base;
          g.fillRect(0, 0, c.width, c.height);

          g.fillStyle = "rgba(255,255,255,0.1)";
          g.fillRect(0, 22, c.width, 8);
          g.fillRect(0, c.height - 22, c.width, 6);

          g.fillStyle = "#d9b145";
          g.fillRect(0, c.height - 30, c.width, 12);

          g.fillStyle = "#a84dd8";
          g.fillRect(0, 52, c.width, 6);

          for (let x = 64; x < c.width; x += 96) {
            g.strokeStyle = "rgba(16,27,45,0.45)";
            g.lineWidth = 2;
            g.beginPath();
            g.moveTo(x, 0);
            g.lineTo(x, c.height);
            g.stroke();
          }

          for (let i = 0; i < 90; i++) {
            g.strokeStyle = `rgba(118,245,255,${rand(0.06, 0.18).toFixed(3)})`;
            g.lineWidth = rand(4, 9);
            g.beginPath();
            const x = rand(-120, c.width - 40);
            const y = rand(130, 226);
            g.moveTo(x, y);
            g.lineTo(x + rand(120, 260), y - rand(26, 54));
            g.stroke();
          }

          for (let i = 0; i < 2800; i++) {
            const v = randInt(80, 180);
            g.fillStyle = `rgba(${v},${Math.max(65, v - 20)},${Math.max(80, v - 5)},${rand(0.03, 0.12).toFixed(3)})`;
            g.fillRect(rand(0, c.width), rand(0, c.height), rand(1, 2.5), rand(1, 2.5));
          }

          const t = new THREE.CanvasTexture(c);
          return this.finalizeTexture(t, 1, 1, true);
        }

        createTrainWindowTexture() {
          const c = document.createElement("canvas");
          c.width = 256;
          c.height = 256;
          const g = c.getContext("2d");

          const glass = g.createLinearGradient(0, 0, 0, c.height);
          glass.addColorStop(0, "#8bc6eb");
          glass.addColorStop(0.4, "#4f84ae");
          glass.addColorStop(1, "#213d57");
          g.fillStyle = glass;
          g.fillRect(0, 0, c.width, c.height);

          g.fillStyle = "rgba(255,255,255,0.2)";
          g.fillRect(0, 26, c.width, 10);
          g.fillStyle = "rgba(255,255,255,0.08)";
          g.fillRect(0, 54, c.width, 6);

          for (let i = 0; i < 22; i++) {
            g.strokeStyle = `rgba(255,255,255,${rand(0.03, 0.08).toFixed(3)})`;
            g.lineWidth = rand(1, 2.4);
            g.beginPath();
            const x = rand(-90, c.width);
            const y = rand(0, c.height);
            g.moveTo(x, y + rand(-22, 22));
            g.lineTo(x + rand(80, 180), y + rand(-12, 30));
            g.stroke();
          }

          for (let i = 0; i < 900; i++) {
            g.fillStyle = `rgba(12,24,38,${rand(0.02, 0.08).toFixed(3)})`;
            g.fillRect(rand(0, c.width), rand(0, c.height), rand(1, 2.2), rand(1, 2.2));
          }

          const t = new THREE.CanvasTexture(c);
          return this.finalizeTexture(t, 1, 1, true);
        }

        createPipeTexture() {
          const c = document.createElement("canvas");
          c.width = 1024;
          c.height = 128;
          const g = c.getContext("2d");

          const base = g.createLinearGradient(0, 0, 0, c.height);
          base.addColorStop(0, "#1d5f92");
          base.addColorStop(0.52, "#174a73");
          base.addColorStop(1, "#123754");
          g.fillStyle = base;
          g.fillRect(0, 0, c.width, c.height);

          g.fillStyle = "#b7852d";
          g.fillRect(0, c.height - 24, c.width, 24);

          g.fillStyle = "#9d51d6";
          g.fillRect(0, 24, c.width, 5);

          for (let i = 0; i < 52; i++) {
            g.strokeStyle = `rgba(76,237,255,${rand(0.08, 0.26).toFixed(3)})`;
            g.lineWidth = rand(3, 7);
            g.beginPath();
            const x = rand(-160, c.width);
            const y = rand(48, 118);
            g.moveTo(x, y);
            g.lineTo(x + rand(80, 220), y - rand(16, 38));
            g.stroke();
          }

          for (let x = 40; x < c.width; x += 176) {
            g.fillStyle = "rgba(201,58,66,0.8)";
            g.fillRect(x, 28, 22, 60);
            g.fillStyle = "rgba(255,255,255,0.16)";
            g.fillRect(x + 4, 32, 6, 20);
          }

          for (let i = 0; i < 1100; i++) {
            g.fillStyle = `rgba(255,255,255,${rand(0.015, 0.06).toFixed(3)})`;
            g.fillRect(rand(0, c.width), rand(0, c.height), rand(1, 2.4), rand(1, 2.4));
          }

          const t = new THREE.CanvasTexture(c);
          return this.finalizeTexture(t, 1, 1, true);
        }

        buildPatterns() {
          return [
            {
              name: "single",
              minDistance: 0,
              weight: 16,
              spawn: (z) => {
                const lane = randInt(0, 2);
                this.spawnObstacle("BARRIER_SMALL", lane, z);
                this.coinManager.spawnLine(lane, z + 2.4, 5, 1.9, 1.1);
                return z + 12;
              }
            },
            {
              name: "double",
              minDistance: 180,
              weight: 15,
              spawn: (z) => {
                const openLane = randInt(0, 2);
                for (let lane = 0; lane < 3; lane++) {
                  if (lane !== openLane) this.spawnObstacle("BARRIER_SMALL", lane, z);
                }
                this.coinManager.spawnLine(openLane, z + 1.8, 6, 2.0, 1.1);
                return z + 14;
              }
            },
            {
              name: "overhead",
              minDistance: 60,
              weight: 18,
              spawn: (z) => {
                const type = Math.random() < 0.6 ? "OVERHEAD_SIGN" : "OVERHEAD_BEAM";
                this.spawnObstacle(type, "all", z);
                this.coinManager.spawnLine(randInt(0, 2), z + 2.2, 6, 2.2, 0.55);
                return z + 15;
              }
            },
            {
              name: "duckTunnel",
              minDistance: 180,
              weight: 13,
              spawn: (z) => {
                this.spawnObstacle("OVERHEAD_SIGN", "all", z);
                this.spawnObstacle("OVERHEAD_BEAM", "all", z + 6.2);
                this.coinManager.spawnLine(randInt(0, 2), z + 1.6, 8, 1.7, 0.5);
                return z + 18;
              }
            },
            {
              name: "trainCorridor",
              minDistance: 680,
              weight: 11,
              spawn: (z) => {
                this.spawnObstacle("TRAIN", 0, z);
                this.spawnObstacle("TRAIN", 2, z);
                this.coinManager.spawnLine(1, z + 2.4, 10, 1.9, 1.2);
                return z + 22;
              }
            },
            {
              name: "trainSingle",
              minDistance: 280,
              weight: 10,
              spawn: (z) => {
                const blockedLane = randInt(0, 2);
                this.spawnObstacle("TRAIN", blockedLane, z);
                for (let lane = 0; lane < 3; lane++) {
                  if (lane !== blockedLane) {
                    this.coinManager.spawnLine(lane, z + 2.2, 7, 2.0, 1.1);
                  }
                }
                return z + 21;
              }
            },
            {
              name: "movingTrainSmash",
              minDistance: 720,
              weight: 9,
              spawn: (z) => {
                const lane = randInt(0, 2);
                this.spawnObstacle("TRAIN_MOVING", lane, z);
                const smashType = Math.random() < 0.5 ? "ROADBLOCK" : "BARRIER_LARGE";
                this.spawnObstacle(smashType, lane, z + rand(8, 12));
                const safeLane = (lane + (Math.random() < 0.5 ? 1 : 2)) % 3;
                this.coinManager.spawnLine(safeLane, z + 2.0, 8, 1.9, 1.2);
                return z + 24;
              }
            },
            {
              name: "zigzag",
              minDistance: 950,
              weight: 8,
              spawn: (z) => {
                const seq = [0, 1, 2];
                if (Math.random() < 0.5) seq.reverse();
                this.spawnObstacle("ROADBLOCK", seq[0], z);
                this.spawnObstacle("ROADBLOCK", seq[1], z + 8);
                this.spawnObstacle("ROADBLOCK", seq[2], z + 16);
                this.coinManager.spawnDiagonal(z + 1.4, 10, 2.0);
                return z + 28;
              }
            },
            {
              name: "jumpSlideCombo",
              minDistance: 1250,
              weight: 7,
              spawn: (z) => {
                this.spawnObstacle("BARRIER_LARGE", 0, z);
                this.spawnObstacle("BARRIER_LARGE", 1, z);
                this.spawnObstacle("BARRIER_LARGE", 2, z);
                this.spawnObstacle("OVERHEAD_SIGN", "all", z + 14);
                this.coinManager.spawnArc(randInt(0, 2), z + 2.0, 7, 2.0);
                return z + 29;
              }
            },
            {
              name: "doubleLaneBlock",
              minDistance: 620,
              weight: 10,
              spawn: (z) => {
                if (Math.random() < 0.5) {
                  this.spawnObstacle("ROADBLOCK_DOUBLE", "leftTwo", z);
                  this.coinManager.spawnLine(2, z + 2.0, 7, 2.0, 1.1);
                } else {
                  this.spawnObstacle("ROADBLOCK_DOUBLE", "rightTwo", z);
                  this.coinManager.spawnLine(0, z + 2.0, 7, 2.0, 1.1);
                }
                return z + 16;
              }
            },
            {
              name: "coneSprint",
              minDistance: 220,
              weight: 11,
              spawn: (z) => {
                const laneA = randInt(0, 2);
                const laneB = randInt(0, 2);
                this.spawnObstacle("CONE_ROW", laneA, z);
                this.spawnObstacle("CONE_ROW", laneB, z + 6.4);
                this.coinManager.spawnDiagonal(z + 1.2, 8, 1.9);
                return z + 16.5;
              }
            },
            {
              name: "lowPipeSwitch",
              minDistance: 440,
              weight: 9,
              spawn: (z) => {
                const slideLane = randInt(0, 2);
                this.spawnObstacle("LOW_PIPE", slideLane, z);
                const laneAfter = (slideLane + (Math.random() < 0.5 ? 1 : 2)) % 3;
                this.spawnObstacle("BARRIER_SMALL", laneAfter, z + 7.2);
                this.coinManager.spawnLine(slideLane, z + 1.3, 5, 1.8, 0.56);
                this.coinManager.spawnLine(laneAfter, z + 8.8, 4, 1.8, 1.2);
                return z + 17;
              }
            },
            {
              name: "signalSlalom",
              minDistance: 760,
              weight: 8,
              spawn: (z) => {
                const seq = [0, 1, 2];
                if (Math.random() < 0.5) seq.reverse();
                this.spawnObstacle("SIGNAL_POST", seq[0], z);
                this.spawnObstacle("SIGNAL_POST", seq[1], z + 7.4);
                this.spawnObstacle("SIGNAL_POST", seq[2], z + 14.8);
                this.coinManager.spawnDiagonal(z + 0.8, 10, 1.9);
                return z + 24;
              }
            },
            {
              name: "cartChaos",
              minDistance: 980,
              weight: 7,
              spawn: (z) => {
                const jumpLane = randInt(0, 2);
                this.spawnObstacle("MAINTENANCE_CART", jumpLane, z);
                const postLane = (jumpLane + (Math.random() < 0.5 ? 1 : 2)) % 3;
                this.spawnObstacle("SIGNAL_POST", postLane, z + 6.8);
                this.spawnObstacle("LOW_PIPE", jumpLane, z + 12.5);
                this.coinManager.spawnArc(jumpLane, z + 0.9, 6, 1.75);
                const safeLane = 3 - jumpLane - postLane;
                this.coinManager.spawnLine(safeLane, z + 8.0, 6, 1.9, 1.1);
                return z + 22;
              }
            },
            {
              name: "coinBreather",
              minDistance: 0,
              weight: 5,
              spawn: (z) => {
                this.coinManager.spawnDiagonal(z + 2, 9, 2.1);
                return z + 13;
              }
            }
          ];
        }

        getPool(type) {
          if (!this.pools[type]) this.pools[type] = [];
          return this.pools[type];
        }

        createObstacle(type) {
          const def = OBSTACLE_DEFS[type];
          const group = new THREE.Group();
          const object = {
            type,
            kind: def.kind,
            def,
            mesh: group,
            x: 0,
            y: def.y,
            z: 0,
            w: def.w,
            h: def.h,
            d: def.d,
            movingSpeed: 0,
            airborne: false,
            collidable: true,
            vx: 0,
            vy: 0,
            vz: 0,
            spinX: 0,
            spinY: 0,
            spinZ: 0,
            hasRamp: false,
            rampRoot: null,
            rampDepth: 3.4
          };

          if (type === "TRAIN" || type === "TRAIN_MOVING") {
            const bodyMat = new THREE.MeshLambertMaterial({
              color: 0xffffff,
              map: this.trainBodyTexture
            });
            const trimMat = new THREE.MeshLambertMaterial({ color: 0x1f2f45 });
            const stripeMat = new THREE.MeshLambertMaterial({ color: 0xd9ebff });
            const roofMat = new THREE.MeshLambertMaterial({ color: 0x50657f });
            const windowMat = new THREE.MeshLambertMaterial({
              color: 0xffffff,
              map: this.trainWindowTexture,
              emissive: 0x1f354a,
              emissiveIntensity: 0.42,
              side: THREE.DoubleSide
            });
            const doorMat = new THREE.MeshLambertMaterial({ color: 0x2d4460 });
            const wheelMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });

            const body = new THREE.Mesh(
              new THREE.BoxGeometry(def.w, def.h * 0.84, def.d),
              bodyMat
            );
            body.position.y = -0.04;
            group.add(body);

            const lower = new THREE.Mesh(
              new THREE.BoxGeometry(def.w * 0.98, 0.38, def.d * 0.96),
              trimMat
            );
            lower.position.y = -def.h * 0.38;
            group.add(lower);

            const roof = new THREE.Mesh(
              new THREE.BoxGeometry(def.w * 0.92, 0.26, def.d * 0.96),
              roofMat
            );
            roof.position.y = def.h * 0.43;
            group.add(roof);

            const stripe = new THREE.Mesh(
              new THREE.BoxGeometry(def.w * 1.01, 0.2, def.d * 0.95),
              stripeMat
            );
            stripe.position.y = -0.1;
            group.add(stripe);

            for (let zRib = -def.d * 0.42; zRib <= def.d * 0.42; zRib += 2.2) {
              const rib = new THREE.Mesh(
                new THREE.BoxGeometry(def.w * 0.9, 0.04, 0.07),
                new THREE.MeshLambertMaterial({ color: 0x8ca0b4 })
              );
              rib.position.set(0, def.h * 0.56, zRib);
              group.add(rib);
            }

            const sideRailMat = new THREE.MeshLambertMaterial({ color: 0x9fb0c0 });
            const sideRailL = new THREE.Mesh(new THREE.BoxGeometry(0.025, 0.06, def.d * 0.86), sideRailMat);
            const sideRailR = new THREE.Mesh(new THREE.BoxGeometry(0.025, 0.06, def.d * 0.86), sideRailMat);
            sideRailL.position.set(-def.w * 0.46, 1.04, 0);
            sideRailR.position.set(def.w * 0.46, 1.04, 0);
            group.add(sideRailL, sideRailR);

            const underWireMat = new THREE.MeshLambertMaterial({ color: 0x131920 });
            const underWireA = new THREE.Mesh(new THREE.BoxGeometry(def.w * 0.62, 0.03, def.d * 0.88), underWireMat);
            const underWireB = new THREE.Mesh(new THREE.BoxGeometry(def.w * 0.42, 0.03, def.d * 0.88), underWireMat);
            underWireA.position.set(0, -def.h * 0.44, 0);
            underWireB.position.set(0, -def.h * 0.41, 0);
            group.add(underWireA, underWireB);

            const endCapGeo = new THREE.BoxGeometry(def.w * 0.98, def.h * 0.76, 0.4);
            const frontCap = new THREE.Mesh(endCapGeo, trimMat);
            const backCap = new THREE.Mesh(endCapGeo, trimMat);
            frontCap.position.set(0, 0.02, -def.d * 0.5 + 0.2);
            backCap.position.set(0, 0.02, def.d * 0.5 - 0.2);
            group.add(frontCap, backCap);

            const routeSignMat = new THREE.MeshLambertMaterial({ color: 0xffe66d, emissive: 0x6c4b00, emissiveIntensity: 0.24 });
            const routeSignFront = new THREE.Mesh(new THREE.BoxGeometry(def.w * 0.42, 0.2, 0.05), routeSignMat);
            const routeSignBack = routeSignFront.clone();
            routeSignFront.position.set(0, 1.12, -def.d * 0.5 - 0.02);
            routeSignBack.position.set(0, 1.12, def.d * 0.5 + 0.02);
            group.add(routeSignFront, routeSignBack);

            const doorZs = [-4.5, 0, 4.5];
            for (const zDoor of doorZs) {
              const doorL = new THREE.Mesh(new THREE.PlaneGeometry(0.95, 1.2), doorMat);
              const doorR = new THREE.Mesh(new THREE.PlaneGeometry(0.95, 1.2), doorMat);
              doorL.position.set(-def.w * 0.5 - 0.02, -0.05, zDoor);
              doorR.position.set(def.w * 0.5 + 0.02, -0.05, zDoor);
              doorL.rotation.y = -Math.PI * 0.5;
              doorR.rotation.y = Math.PI * 0.5;
              group.add(doorL, doorR);
            }

            for (let i = -6.4; i <= 6.4; i += 1.8) {
              if (Math.abs(i) < 0.9 || Math.abs(i - 4.5) < 0.6 || Math.abs(i + 4.5) < 0.6) continue;
              const winL = new THREE.Mesh(new THREE.PlaneGeometry(0.76, 0.58), windowMat);
              const winR = new THREE.Mesh(new THREE.PlaneGeometry(0.76, 0.58), windowMat);
              winL.position.set(-def.w * 0.5 - 0.025, 0.56, i);
              winR.position.set(def.w * 0.5 + 0.025, 0.56, i);
              winL.rotation.y = -Math.PI * 0.5;
              winR.rotation.y = Math.PI * 0.5;
              group.add(winL, winR);
            }

            const graffitiPalette = [0xff6b6b, 0x4ecdc4, 0xffe66d, 0x95e1d3, 0xf38181, 0xaa96da];
            for (let i = 0; i < 3; i++) {
              const decalMat = new THREE.MeshLambertMaterial({
                color: graffitiPalette[randInt(0, graffitiPalette.length - 1)],
                transparent: true,
                opacity: 0.72
              });
              const decalL = new THREE.Mesh(new THREE.PlaneGeometry(rand(0.7, 1.1), rand(0.28, 0.5)), decalMat);
              const decalR = new THREE.Mesh(new THREE.PlaneGeometry(rand(0.7, 1.1), rand(0.28, 0.5)), decalMat.clone());
              const z = rand(-5.7, 5.7);
              decalL.position.set(-def.w * 0.5 - 0.03, rand(-0.2, 0.3), z);
              decalR.position.set(def.w * 0.5 + 0.03, rand(-0.2, 0.3), z);
              decalL.rotation.y = -Math.PI * 0.5;
              decalR.rotation.y = Math.PI * 0.5;
              decalL.rotation.z = rand(-0.18, 0.18);
              decalR.rotation.z = rand(-0.18, 0.18);
              group.add(decalL, decalR);
            }

            for (const zUnit of [-4.8, 0, 4.8]) {
              const ac = new THREE.Mesh(
                new THREE.BoxGeometry(def.w * 0.56, 0.13, 1.5),
                new THREE.MeshLambertMaterial({ color: 0x6d8096 })
              );
              ac.position.set(0, def.h * 0.58, zUnit);
              group.add(ac);
            }

            for (const sideX of [-0.72, 0.72]) {
              const rail = new THREE.Mesh(
                new THREE.BoxGeometry(0.03, 0.05, def.d * 0.8),
                new THREE.MeshLambertMaterial({ color: 0x91a2b3 })
              );
              rail.position.set(sideX, def.h * 0.59, 0);
              group.add(rail);
            }

            for (const bogieZ of [-def.d * 0.34, def.d * 0.34]) {
              const bogie = new THREE.Mesh(
                new THREE.BoxGeometry(def.w * 0.74, 0.18, 1.6),
                new THREE.MeshLambertMaterial({ color: 0x222a32 })
              );
              bogie.position.set(0, -def.h * 0.49, bogieZ);
              group.add(bogie);

              for (const xSign of [-1, 1]) {
                for (const zOffset of [-0.5, 0.5]) {
                  const wheel = new THREE.Mesh(new THREE.CylinderGeometry(0.21, 0.21, 0.14, 12), wheelMat);
                  wheel.rotation.z = Math.PI * 0.5;
                  wheel.position.set(xSign * 0.74, -def.h * 0.53, bogieZ + zOffset);
                  group.add(wheel);
                }
              }
            }

            if (type === "TRAIN_MOVING") {
              const nose = new THREE.Mesh(
                new THREE.BoxGeometry(def.w * 0.96, def.h * 0.42, 0.62),
                new THREE.MeshLambertMaterial({ color: 0x263a52 })
              );
              nose.position.set(0, 0.4, -def.d * 0.5 - 0.06);
              group.add(nose);

              const windshield = new THREE.Mesh(
                new THREE.PlaneGeometry(def.w * 0.72, 0.75),
                new THREE.MeshLambertMaterial({
                  color: 0x9ed7fa,
                  emissive: 0x22455d,
                  emissiveIntensity: 0.45,
                  side: THREE.DoubleSide
                })
              );
              windshield.position.set(0, 0.86, -def.d * 0.5 - 0.38);
              group.add(windshield);

              const lightMat = new THREE.MeshBasicMaterial({ color: 0xfff0b8 });
              const lightL = new THREE.Mesh(new THREE.SphereGeometry(0.12, 10, 10), lightMat);
              const lightR = new THREE.Mesh(new THREE.SphereGeometry(0.12, 10, 10), lightMat);
              lightL.position.set(-0.56, 0.72, -def.d * 0.5 - 0.38);
              lightR.position.set(0.56, 0.72, -def.d * 0.5 - 0.38);
              group.add(lightL, lightR);

              const coupler = new THREE.Mesh(
                new THREE.BoxGeometry(0.44, 0.14, 0.2),
                new THREE.MeshLambertMaterial({ color: 0x171d24 })
              );
              coupler.position.set(0, -0.5, -def.d * 0.5 - 0.22);
              group.add(coupler);
            } else {
              const backWindow = new THREE.Mesh(
                new THREE.PlaneGeometry(def.w * 0.65, 0.72),
                new THREE.MeshLambertMaterial({
                  color: 0x8abddf,
                  emissive: 0x1f3449,
                  emissiveIntensity: 0.35,
                  side: THREE.DoubleSide
                })
              );
              backWindow.position.set(0, 0.76, -def.d * 0.5 - 0.01);
              group.add(backWindow);
            }

            const rampRoot = new THREE.Group();
            const rampDepth = 3.4;
            const rampTopLocalY = def.h * 0.5 + 0.04;
            const rampBottomLocalY = -def.y + 0.06;
            const rampRise = rampTopLocalY - rampBottomLocalY;
            const rampAngle = -Math.atan2(rampRise, rampDepth);
            const rampCenterY = rampBottomLocalY + rampRise * 0.5;
            const rampCenterZ = -def.d * 0.5 - rampDepth * 0.5 + 0.08;

            const plankMat = new THREE.MeshLambertMaterial({ color: 0x9b6a3f, map: this.crateTexture });
            const plank = new THREE.Mesh(new THREE.BoxGeometry(def.w * 0.86, 0.12, rampDepth), plankMat);
            plank.position.set(0, rampCenterY, rampCenterZ);
            plank.rotation.x = rampAngle;
            rampRoot.add(plank);

            const rampRailMat = new THREE.MeshLambertMaterial({ color: 0x6f4a2b });
            const rampRailL = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.12, rampDepth * 0.96), rampRailMat);
            const rampRailR = rampRailL.clone();
            rampRailL.position.set(-def.w * 0.39, rampCenterY + 0.08, rampCenterZ);
            rampRailR.position.set(def.w * 0.39, rampCenterY + 0.08, rampCenterZ);
            rampRailL.rotation.x = rampAngle;
            rampRailR.rotation.x = rampAngle;
            rampRoot.add(rampRailL, rampRailR);

            for (let zStep = -rampDepth * 0.45; zStep <= rampDepth * 0.45; zStep += 0.42) {
              const tie = new THREE.Mesh(new THREE.BoxGeometry(def.w * 0.78, 0.04, 0.06), new THREE.MeshLambertMaterial({ color: 0x7c512d }));
              tie.position.set(0, rampCenterY + Math.sin(rampAngle) * zStep, rampCenterZ + zStep);
              tie.rotation.x = rampAngle;
              rampRoot.add(tie);
            }

            rampRoot.visible = false;
            group.add(rampRoot);
            object.rampRoot = rampRoot;
            object.rampDepth = rampDepth;
          } else if (type === "OVERHEAD_SIGN" || type === "OVERHEAD_BEAM") {
            const boardMat = new THREE.MeshLambertMaterial({
              color: def.color,
              map: this.hazardTexture
            });
            const board = new THREE.Mesh(
              new THREE.BoxGeometry(def.w, def.h, def.d),
              boardMat
            );
            board.position.y = 0;
            group.add(board);
            const postMat = new THREE.MeshLambertMaterial({ color: 0x5f6e7f });
            for (const x of [-3.4, -1.7, 0, 1.7, 3.4]) {
              const pole = new THREE.Mesh(new THREE.BoxGeometry(0.1, def.y * 2, 0.1), postMat);
              pole.position.set(x, -def.y, 0);
              group.add(pole);
            }

            const boltMat = new THREE.MeshLambertMaterial({ color: 0xd6dce3 });
            for (const x of [-def.w * 0.45, -def.w * 0.15, def.w * 0.15, def.w * 0.45]) {
              const bolt = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.03, 7), boltMat);
              bolt.rotation.x = Math.PI * 0.5;
              bolt.position.set(x, 0, def.d * 0.52);
              group.add(bolt);
            }
          } else {
            if (type === "BARRIER_SMALL") {
              const topBeam = new THREE.Mesh(
                new THREE.BoxGeometry(def.w * 0.98, 0.24, def.d * 0.8),
                new THREE.MeshLambertMaterial({ color: 0xff7c3e, map: this.hazardTexture })
              );
              topBeam.position.y = 0.42;
              group.add(topBeam);

              const legGeo = new THREE.BoxGeometry(0.12, 0.62, 0.12);
              const legMat = new THREE.MeshLambertMaterial({ color: 0x434d59 });
              for (const x of [-0.92, 0.92]) {
                const leg = new THREE.Mesh(legGeo, legMat);
                leg.position.set(x, 0.08, 0);
                leg.rotation.z = x < 0 ? 0.25 : -0.25;
                group.add(leg);
              }

              const reflector = new THREE.Mesh(
                new THREE.BoxGeometry(def.w * 0.72, 0.06, 0.05),
                new THREE.MeshBasicMaterial({ color: 0xfff3c8 })
              );
              reflector.position.set(0, 0.42, def.d * 0.42);
              group.add(reflector);
            } else if (type === "BARRIER_LARGE") {
              const crate = new THREE.Mesh(
                new THREE.BoxGeometry(def.w, def.h, def.d),
                new THREE.MeshLambertMaterial({ color: 0xb86c3d, map: this.crateTexture })
              );
              group.add(crate);

              const strapMat = new THREE.MeshLambertMaterial({ color: 0x384455 });
              const strapA = new THREE.Mesh(new THREE.BoxGeometry(def.w * 1.01, 0.12, 0.08), strapMat);
              const strapB = new THREE.Mesh(new THREE.BoxGeometry(def.w * 1.01, 0.12, 0.08), strapMat);
              strapA.position.set(0, def.h * 0.18, def.d * 0.34);
              strapB.position.set(0, -def.h * 0.18, -def.d * 0.34);
              group.add(strapA, strapB);
            } else if (type === "CONE_ROW") {
              const baseGeo = new THREE.CylinderGeometry(0.21, 0.3, 0.12, 10);
              const coneGeo = new THREE.ConeGeometry(0.18, 0.44, 12);
              const coneMat = new THREE.MeshLambertMaterial({ color: 0xff8a35 });
              const stripeMat = new THREE.MeshLambertMaterial({ color: 0xf8f4d8 });
              for (const x of [-0.72, 0, 0.72]) {
                const cone = new THREE.Group();
                const base = new THREE.Mesh(baseGeo, new THREE.MeshLambertMaterial({ color: 0x424c58 }));
                base.position.y = -0.3;
                const body = new THREE.Mesh(coneGeo, coneMat);
                body.position.y = -0.02;
                const stripe = new THREE.Mesh(new THREE.TorusGeometry(0.13, 0.02, 8, 14), stripeMat);
                stripe.position.y = 0.02;
                stripe.rotation.x = Math.PI * 0.5;
                cone.add(base, body, stripe);
                cone.position.set(x, def.y, 0);
                group.add(cone);
              }
              const tape = new THREE.Mesh(
                new THREE.BoxGeometry(def.w * 0.86, 0.05, 0.04),
                new THREE.MeshLambertMaterial({ color: 0xffefbf })
              );
              tape.position.set(0, def.y + 0.19, 0.15);
              group.add(tape);
            } else if (type === "LOW_PIPE") {
              const pipeMat = new THREE.MeshLambertMaterial({
                color: 0xffffff,
                map: this.pipeTexture,
                emissive: 0x0f2030,
                emissiveIntensity: 0.18
              });
              const pipe = new THREE.Mesh(new THREE.CylinderGeometry(0.16, 0.16, def.w * 0.95, 14), pipeMat);
              pipe.rotation.z = Math.PI * 0.5;
              group.add(pipe);
              for (const x of [-def.w * 0.46, def.w * 0.46]) {
                const stand = new THREE.Mesh(new THREE.BoxGeometry(0.16, def.y * 2, 0.16), new THREE.MeshLambertMaterial({ color: 0x535d67 }));
                stand.position.set(x, -def.y, 0);
                group.add(stand);
              }
              const caution = new THREE.Mesh(
                new THREE.BoxGeometry(def.w * 0.92, 0.06, 0.03),
                new THREE.MeshLambertMaterial({ color: 0xf3d256 })
              );
              caution.position.set(0, 0, def.d * 0.44);
              group.add(caution);
            } else if (type === "SIGNAL_POST") {
              const post = new THREE.Mesh(
                new THREE.BoxGeometry(0.32, def.h * 0.9, 0.32),
                new THREE.MeshLambertMaterial({ color: 0x6d7784 })
              );
              post.position.y = -0.16;
              group.add(post);
              const lightBox = new THREE.Mesh(
                new THREE.BoxGeometry(0.72, 0.42, 0.42),
                new THREE.MeshLambertMaterial({ color: 0x303743 })
              );
              lightBox.position.y = 0.74;
              group.add(lightBox);
              const redLamp = new THREE.Mesh(new THREE.SphereGeometry(0.11, 10, 10), new THREE.MeshBasicMaterial({ color: 0xff4f4f }));
              const amberLamp = new THREE.Mesh(new THREE.SphereGeometry(0.11, 10, 10), new THREE.MeshBasicMaterial({ color: 0xffbe4d }));
              redLamp.position.set(0, 0.84, 0.24);
              amberLamp.position.set(0, 0.63, 0.24);
              group.add(redLamp, amberLamp);
              const basePlate = new THREE.Mesh(
                new THREE.BoxGeometry(0.86, 0.12, 0.86),
                new THREE.MeshLambertMaterial({ color: 0x49525f })
              );
              basePlate.position.y = -1.22;
              group.add(basePlate);
            } else if (type === "MAINTENANCE_CART") {
              const cartBase = new THREE.Mesh(
                new THREE.BoxGeometry(def.w, def.h * 0.58, def.d),
                new THREE.MeshLambertMaterial({ color: 0xb46737, map: this.crateTexture })
              );
              cartBase.position.y = -0.08;
              group.add(cartBase);
              const tarp = new THREE.Mesh(
                new THREE.BoxGeometry(def.w * 0.92, 0.28, def.d * 0.86),
                new THREE.MeshLambertMaterial({ color: 0x2e4b67 })
              );
              tarp.position.y = def.h * 0.28;
              group.add(tarp);
              const railMat = new THREE.MeshLambertMaterial({ color: 0x8895a3 });
              const railL = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.3, def.d * 0.82), railMat);
              const railR = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.3, def.d * 0.82), railMat);
              railL.position.set(-def.w * 0.46, 0.12, 0);
              railR.position.set(def.w * 0.46, 0.12, 0);
              group.add(railL, railR);
              for (const x of [-0.82, 0.82]) {
                for (const z of [-0.44, 0.44]) {
                  const wheel = new THREE.Mesh(new THREE.CylinderGeometry(0.16, 0.16, 0.12, 12), new THREE.MeshLambertMaterial({ color: 0x1d2229 }));
                  wheel.rotation.z = Math.PI * 0.5;
                  wheel.position.set(x, -0.56, z);
                  group.add(wheel);
                }
              }
            } else {
              const core = new THREE.Mesh(
                new THREE.BoxGeometry(def.w, def.h, def.d),
                new THREE.MeshLambertMaterial({ color: def.color, map: this.hazardTexture })
              );
              group.add(core);
              const cap = new THREE.Mesh(
                new THREE.BoxGeometry(def.w * 0.86, Math.min(0.2, def.h * 0.18), def.d * 0.86),
                new THREE.MeshLambertMaterial({ color: 0x6f7781 })
              );
              cap.position.y = def.h * 0.42;
              group.add(cap);
              const lamp = new THREE.Mesh(
                new THREE.SphereGeometry(0.09, 10, 10),
                new THREE.MeshBasicMaterial({ color: 0xfff2b3 })
              );
              lamp.position.set(0, def.h * 0.28, def.d * 0.38);
              group.add(lamp);
            }
          }

          group.visible = false;
          this.scene.add(group);
          return object;
        }

        acquire(type) {
          const pool = this.getPool(type);
          return pool.pop() || this.createObstacle(type);
        }

        release(obstacle) {
          obstacle.mesh.visible = false;
          this.getPool(obstacle.type).push(obstacle);
        }

        laneToX(laneKey) {
          if (laneKey === "all") return 0;
          if (laneKey === "leftTwo") return -1.25;
          if (laneKey === "rightTwo") return 1.25;
          return CONFIG.lanePositions[laneKey];
        }

        spawnObstacle(type, laneKey, z) {
          const obstacle = this.acquire(type);
          const def = OBSTACLE_DEFS[type];
          obstacle.type = type;
          obstacle.def = def;
          obstacle.kind = def.kind;
          obstacle.w = def.w;
          obstacle.h = def.h;
          obstacle.d = def.d;
          obstacle.x = this.laneToX(laneKey);
          obstacle.y = def.y;
          obstacle.z = z;
          obstacle.movingSpeed = type === "TRAIN_MOVING" ? rand(9, 14) : 0;
          obstacle.airborne = false;
          obstacle.collidable = true;
          obstacle.vx = 0;
          obstacle.vy = 0;
          obstacle.vz = 0;
          obstacle.spinX = 0;
          obstacle.spinY = 0;
          obstacle.spinZ = 0;
          obstacle.hasRamp = false;
          obstacle.mesh.rotation.set(0, 0, 0);
          obstacle.mesh.position.set(obstacle.x, obstacle.y, obstacle.z);
          obstacle.mesh.visible = true;

          if (type === "TRAIN") {
            const rampChance = 0.8;
            obstacle.hasRamp = Math.random() < rampChance;
            if (obstacle.rampRoot) obstacle.rampRoot.visible = obstacle.hasRamp;

            if (obstacle.hasRamp && Number.isInteger(laneKey)) {
              const roofCoinY = def.y + def.h * 0.5 + 0.45;
              const roofCoinStart = z - def.d * 0.34;
              this.coinManager.spawnLine(laneKey, roofCoinStart, 7, 1.85, roofCoinY);
            }
          } else if (type === "TRAIN_MOVING") {
            obstacle.hasRamp = false;
            if (obstacle.rampRoot) obstacle.rampRoot.visible = false;
          } else if (obstacle.rampRoot) {
            obstacle.rampRoot.visible = false;
          }

          this.active.push(obstacle);
          return obstacle;
        }

        launchObstacle(obstacle, train) {
          obstacle.airborne = true;
          obstacle.collidable = false;
          obstacle.kind = "debris";
          const sideImpulse = (obstacle.x - train.x) * 1.4;
          obstacle.vx = rand(-4.2, 4.2) + sideImpulse;
          obstacle.vy = rand(8.0, 12.8);
          obstacle.vz = -rand(15, 24);
          obstacle.spinX = rand(-9, 9);
          obstacle.spinY = rand(-8, 8);
          obstacle.spinZ = rand(-9, 9);
          obstacle.y = Math.max(obstacle.y, 0.6);
          obstacle.mesh.position.y = obstacle.y;
        }

        resolveTrainImpacts() {
          for (const train of this.active) {
            if (train.type !== "TRAIN_MOVING" || train.airborne) continue;
            for (const target of this.active) {
              if (target === train || target.airborne || !target.collidable) continue;
              if (target.type === "TRAIN" || target.type === "TRAIN_MOVING") continue;
              if (target.kind === "slide") continue;

              const xOverlap = Math.abs(train.x - target.x) * 2 < (train.w * 0.92 + target.w);
              if (!xOverlap) continue;

              const targetAhead = target.z > train.z - 0.4;
              const zOverlap = (target.z - train.z) < (train.d * 0.55 + target.d * 0.7);
              if (targetAhead && zOverlap) {
                this.launchObstacle(target, train);
                break;
              }
            }
          }
        }

        getSpawnGap(distance) {
          const progress = clamp(distance / 3200, 0, 1);
          const minGap = lerp(24, 16, progress);
          const maxGap = minGap + 9;
          return rand(minGap, maxGap);
        }

        spawnPattern(distance) {
          const available = this.patterns.filter((p) => distance >= p.minDistance);
          const chosen = weightedChoice(available);
          return chosen.spawn(this.spawnCursor);
        }

        update(dt, speed, distance) {
          for (let i = this.active.length - 1; i >= 0; i--) {
            const o = this.active[i];
            if (o.airborne) {
              o.vy -= 25 * dt;
              o.x += o.vx * dt;
              o.y += o.vy * dt;
              o.z += (o.vz - speed) * dt;
              o.mesh.position.set(o.x, o.y, o.z);
              o.mesh.rotation.x += o.spinX * dt;
              o.mesh.rotation.y += o.spinY * dt;
              o.mesh.rotation.z += o.spinZ * dt;

              const outOfFrame = o.z < CONFIG.despawnZ - 45 || o.y < -6 || Math.abs(o.x) > 24;
              if (outOfFrame) {
                this.release(o);
                this.active.splice(i, 1);
              }
              continue;
            }

            const speedBoost = o.type === "TRAIN_MOVING" ? o.movingSpeed : 0;
            o.z -= (speed + speedBoost) * dt;
            o.mesh.position.z = o.z;
            if (o.z < CONFIG.despawnZ - o.d) {
              this.release(o);
              this.active.splice(i, 1);
            }
          }

          this.resolveTrainImpacts();

          let farthest = 0;
          for (const o of this.active) {
            if (o.airborne) continue;
            farthest = Math.max(farthest, o.z + o.d * 0.5);
          }
          while (farthest < CONFIG.visibleDistance) {
            this.spawnCursor = farthest + this.getSpawnGap(distance);
            const end = this.spawnPattern(distance);
            farthest = Math.max(farthest, end);
          }
        }

        reset() {
          for (let i = this.active.length - 1; i >= 0; i--) {
            this.release(this.active[i]);
          }
          this.active.length = 0;
          this.spawnCursor = 24;
        }
      }

      // ===== SECTION 11: MAIN GAME =====
      class SubwayRunnerGame {
        constructor(rootEl) {
          this.rootEl = rootEl;
          this.state = "menu";
          this.lastTime = 0;
          this.distance = 0;
          this.speed = CONFIG.baseSpeed;
          this.score = 0;
          this.runCoins = 0;
          this.totalCoins = safeReadInt(CONFIG.storage.totalCoins, 0);
          this.highScore = safeReadInt(CONFIG.storage.bestScore, 0);
          this.unlockedCharacterIds = [];
          this.selectedCharacterId = "jake";
          this.characterAbility = buildAbilityFromPrice(0);
          this.shieldCharges = 0;
          this.shakeTime = 0;
          this.shakeAmp = 0;
          this.cameraDip = 0;
          this.cameraX = 0;
          this.crashTimer = 0;
          this.isMobile = matchMedia("(pointer: coarse)").matches;
          this.cutsceneTime = 0;
          this.cutsceneWhistlePlayed = false;
          this.cutsceneStartedRun = false;
          this.cutsceneSkipRequested = false;
          this.deathSeqTime = 0;
          this.deathCuffed = false;
          this.deathKickStarted = false;
          this.deathKickStartX = 0;
          this.deathKickStartZ = 0;
          this.deathDoorSlammed = false;
          this.deathCellImpactDone = false;
          this.deathRocketIgnited = false;
          this.deathNukeDropped = false;
          this.deathNukeExploded = false;
          this.playMode = "runner";
          this.fugitiveLead = 5.2;
          this.fugitiveBurstTimer = 0;
          this.fugitiveSpeedBonus = 0;
          this.nextFugitiveBurst = 7.5;
          this.fugitiveDecisionTimer = 0.65;
          this.copBoostTimer = 0;
          this.copBoostSpawnTimer = 5.2;
          this.copBoosts = [];
          this.copBoostPool = [];
          this.isCopOutcome = false;
          this.copCaughtRunner = false;
          this.runnerPowerUps = [];
          this.runnerPowerUpPool = { magnet: [], sneakers: [], hoverboard: [] };
          this.runnerPowerUpSpawnTimer = 8.2;
          this.activeRunnerPowerUps = { magnet: 0, sneakers: 0, hoverboard: 0 };
          this.wasOnTrainTop = false;
          this.autoFunEnabled = false;
          this.autoRunnerPending = false;
          this.autoRunnerActive = false;
          this.autoBotDecisionTimer = 0;
          this.speedMultiplier = 1;
          this.autoFunSpeedOverdrive = 2.1;
          this.debugLoggingEnabled = true;
          this.telemetryLogTimer = 0;
          this.telemetryLogInterval = 0.65;
          this.unlockedCharacterIds = this.loadUnlockedCharacters();
          this.selectedCharacterId = this.loadSelectedCharacterId();

          this.audio = new AudioManager();
          this.ui = new UIManager();
          this.input = new InputHandler(CONFIG.inputBufferMs);
          this.installAutoFunConsoleControls();

          this.setupRenderer();
          this.setupScene();
          this.track = new TrackSystem(this.scene);
          this.particles = new ParticleSystem(this.scene);
          this.player = new Player(this.scene);
          this.applySelectedCharacter();
          this.chaser = new CopChaser(this.scene);
          this.coinManager = new CoinManager(this.scene);
          this.obstacleManager = new ObstacleManager(this.scene, this.coinManager);
          this.setupCutsceneScene();
          this.setupArrestScene();
          this.setupCopBoostSystem();
          this.setupRunnerPowerUpSystem();

          this.bindUI();
          this.ui.showTouchHint(this.isMobile);
          this.goToMenu();
          this.onResize = this.onResize.bind(this);
          window.addEventListener("resize", this.onResize);
          requestAnimationFrame((t) => this.loop(t));
        }

        setupRenderer() {
          this.renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true
          });
          this.renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.8));
          this.renderer.setSize(window.innerWidth, window.innerHeight);
          this.rootEl.appendChild(this.renderer.domElement);
        }

        setupScene() {
          this.scene = new THREE.Scene();
          this.scene.fog = new THREE.Fog(0xe8e8e8, 55, 170);
          this.scene.background = new THREE.Color(0x8fd8ff);

          this.camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 450);
          this.camera.position.set(0, 8, -12);

          const ambient = new THREE.AmbientLight(0xffffff, 0.72);
          this.scene.add(ambient);
          const hemi = new THREE.HemisphereLight(0xd8f4ff, 0xb18c6a, 0.38);
          this.scene.add(hemi);
          const dir = new THREE.DirectionalLight(0xfff5e6, 0.84);
          dir.position.set(-7, 14, 8);
          this.scene.add(dir);

          const skyline = new THREE.Mesh(
            new THREE.PlaneGeometry(220, 70),
            new THREE.MeshBasicMaterial({ color: 0x9dc0df, transparent: true, opacity: 0.7 })
          );
          skyline.position.set(0, 26, 120);
          this.scene.add(skyline);
        }

        makeCutsceneGraffitiTexture() {
          const c = document.createElement("canvas");
          c.width = 512;
          c.height = 256;
          const g = c.getContext("2d");
          g.clearRect(0, 0, c.width, c.height);
          g.fillStyle = "rgba(0,0,0,0)";
          g.fillRect(0, 0, c.width, c.height);
          g.save();
          g.translate(24, 112);
          g.rotate(-0.03);
          g.fillStyle = "#ff4f8f";
          g.font = "bold 78px Arial Black, Impact, sans-serif";
          g.fillText("I WANT A", 0, 0);
          g.strokeStyle = "#1df4ff";
          g.lineWidth = 6;
          g.strokeText("I WANT A", 0, 0);
          g.restore();

          g.save();
          g.translate(16, 186);
          g.rotate(0.02);
          g.fillStyle = "#ffe76d";
          g.font = "bold 82px Arial Black, Impact, sans-serif";
          g.fillText("ELECTRIC", 0, 0);
          g.strokeStyle = "#ff6f2d";
          g.lineWidth = 7;
          g.strokeText("ELECTRIC", 0, 0);
          g.restore();

          g.save();
          g.translate(182, 224);
          g.rotate(-0.05);
          g.fillStyle = "#b2ff84";
          g.font = "bold 78px Arial Black, Impact, sans-serif";
          g.fillText("BIKE", 0, 0);
          g.strokeStyle = "#2c6cff";
          g.lineWidth = 7;
          g.strokeText("BIKE", 0, 0);
          g.restore();

          const t = new THREE.CanvasTexture(c);
          t.needsUpdate = true;
          return t;
        }

        makeRocketFlameSpriteTexture() {
          const c = document.createElement("canvas");
          c.width = 256;
          c.height = 256;
          const g = c.getContext("2d");
          g.clearRect(0, 0, c.width, c.height);

          g.save();
          g.translate(128, 132);

          const outer = g.createRadialGradient(0, 30, 14, 0, 34, 118);
          outer.addColorStop(0, "rgba(255,245,215,0.96)");
          outer.addColorStop(0.2, "rgba(255,197,88,0.94)");
          outer.addColorStop(0.55, "rgba(255,120,26,0.78)");
          outer.addColorStop(1, "rgba(255,66,0,0)");
          g.fillStyle = outer;
          g.beginPath();
          g.moveTo(0, -104);
          g.quadraticCurveTo(92, -6, 44, 106);
          g.quadraticCurveTo(0, 138, -44, 106);
          g.quadraticCurveTo(-92, -6, 0, -104);
          g.closePath();
          g.fill();

          const core = g.createRadialGradient(0, -4, 8, 0, 24, 58);
          core.addColorStop(0, "rgba(255,255,245,0.95)");
          core.addColorStop(0.4, "rgba(255,232,142,0.86)");
          core.addColorStop(1, "rgba(255,140,32,0)");
          g.fillStyle = core;
          g.beginPath();
          g.moveTo(0, -74);
          g.quadraticCurveTo(48, 2, 20, 78);
          g.quadraticCurveTo(0, 96, -20, 78);
          g.quadraticCurveTo(-48, 2, 0, -74);
          g.closePath();
          g.fill();

          g.restore();

          const t = new THREE.CanvasTexture(c);
          t.needsUpdate = true;
          t.minFilter = THREE.LinearFilter;
          t.magFilter = THREE.LinearFilter;
          t.generateMipmaps = false;
          return t;
        }

        setupCutsceneScene() {
          this.cutsceneGroup = new THREE.Group();
          this.cutsceneGroup.visible = false;
          this.cutsceneGroup.position.set(0, 0, 10);
          this.scene.add(this.cutsceneGroup);

          const trainMat = new THREE.MeshLambertMaterial({ color: 0x375170 });
          const trimMat = new THREE.MeshLambertMaterial({ color: 0x1c2d43 });
          const roofMat = new THREE.MeshLambertMaterial({ color: 0x5a6f86 });
          const windowMat = new THREE.MeshLambertMaterial({
            color: 0x89c6ef,
            emissive: 0x2b3e4d,
            emissiveIntensity: 0.45,
            side: THREE.DoubleSide
          });

          const body = new THREE.Mesh(new THREE.BoxGeometry(2.35, 3.05, 12), trainMat);
          body.position.y = 1.52;
          this.cutsceneGroup.add(body);

          const lower = new THREE.Mesh(new THREE.BoxGeometry(2.28, 0.35, 11.8), trimMat);
          lower.position.y = 0.42;
          this.cutsceneGroup.add(lower);

          const roof = new THREE.Mesh(new THREE.BoxGeometry(2.12, 0.26, 11.5), roofMat);
          roof.position.y = 3.13;
          this.cutsceneGroup.add(roof);

          for (let z = -4.8; z <= 4.8; z += 1.9) {
            const winL = new THREE.Mesh(new THREE.PlaneGeometry(0.72, 0.54), windowMat);
            const winR = new THREE.Mesh(new THREE.PlaneGeometry(0.72, 0.54), windowMat);
            winL.position.set(-1.19, 2.2, z);
            winR.position.set(1.19, 2.2, z);
            winL.rotation.y = -Math.PI * 0.5;
            winR.rotation.y = Math.PI * 0.5;
            this.cutsceneGroup.add(winL, winR);
          }

          const graffitiMat = new THREE.MeshLambertMaterial({
            map: this.makeCutsceneGraffitiTexture(),
            transparent: true,
            opacity: 0
          });
          this.cutsceneGraffiti = new THREE.Mesh(new THREE.PlaneGeometry(1.95, 1.0), graffitiMat);
          this.cutsceneGraffiti.position.set(-1.19, 1.72, 0.15);
          this.cutsceneGraffiti.rotation.y = -Math.PI * 0.5;
          this.cutsceneGroup.add(this.cutsceneGraffiti);

          const sprayMat = new THREE.MeshLambertMaterial({ color: 0x5fe3ff });
          this.cutsceneSpray = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.24, 10), sprayMat);
          this.cutsceneSpray.rotation.z = -Math.PI * 0.4;
          this.cutsceneSpray.visible = false;
          this.scene.add(this.cutsceneSpray);
        }

        setupArrestScene() {
          this.jailGroup = new THREE.Group();
          this.scene.add(this.jailGroup);

          const barMat = new THREE.MeshLambertMaterial({ color: 0x8a94a1 });
          const frameMat = new THREE.MeshLambertMaterial({ color: 0x4b5664 });
          const floorMat = new THREE.MeshLambertMaterial({ color: 0x606a75 });
          const floorDarkMat = new THREE.MeshLambertMaterial({ color: 0x3f4854 });
          const roofDetailMat = new THREE.MeshLambertMaterial({ color: 0x262d36 });
          const stripMat = new THREE.MeshLambertMaterial({ color: 0x7f8a97 });

          const base = new THREE.Mesh(new THREE.BoxGeometry(3.2, 0.24, 3.2), floorMat);
          base.position.y = 0.12;
          this.jailGroup.add(base);

          const baseTrim = new THREE.Mesh(new THREE.BoxGeometry(3.34, 0.08, 3.34), floorDarkMat);
          baseTrim.position.y = 0.27;
          this.jailGroup.add(baseTrim);

          const floorInset = new THREE.Mesh(new THREE.BoxGeometry(2.6, 0.03, 2.6), floorDarkMat);
          floorInset.position.y = 0.255;
          this.jailGroup.add(floorInset);

          const drain = new THREE.Mesh(new THREE.CylinderGeometry(0.33, 0.33, 0.03, 18), stripMat);
          drain.rotation.x = Math.PI * 0.5;
          drain.position.set(0, 0.27, 0.35);
          this.jailGroup.add(drain);

          const backWall = new THREE.Mesh(new THREE.BoxGeometry(3.2, 2.8, 0.16), frameMat);
          backWall.position.set(0, 1.52, 1.48);
          this.jailGroup.add(backWall);

          const sideL = new THREE.Mesh(new THREE.BoxGeometry(0.16, 2.8, 3.2), frameMat);
          const sideR = sideL.clone();
          sideL.position.set(-1.52, 1.52, 0);
          sideR.position.set(1.52, 1.52, 0);
          this.jailGroup.add(sideL, sideR);

          const roof = new THREE.Mesh(new THREE.BoxGeometry(3.2, 0.16, 3.2), frameMat);
          roof.position.set(0, 2.96, 0);
          this.jailGroup.add(roof);

          for (const x of [-1.5, 1.5]) {
            for (const z of [-1.5, 1.5]) {
              const corner = new THREE.Mesh(new THREE.BoxGeometry(0.14, 3.02, 0.14), roofDetailMat);
              corner.position.set(x, 1.51, z);
              this.jailGroup.add(corner);
            }
          }

          const frontRailTop = new THREE.Mesh(new THREE.BoxGeometry(2.85, 0.08, 0.1), roofDetailMat);
          const frontRailMid = new THREE.Mesh(new THREE.BoxGeometry(2.85, 0.08, 0.1), roofDetailMat);
          frontRailTop.position.set(0, 2.72, -1.34);
          frontRailMid.position.set(0, 1.44, -1.34);
          this.jailGroup.add(frontRailTop, frontRailMid);

          for (let i = -3; i <= 3; i++) {
            const bar = new THREE.Mesh(new THREE.BoxGeometry(0.07, 2.6, 0.07), barMat);
            bar.position.set(i * 0.42, 1.48, -1.34);
            this.jailGroup.add(bar);
          }
          for (let i = -2; i <= 2; i++) {
            const barL = new THREE.Mesh(new THREE.BoxGeometry(0.07, 2.6, 0.07), barMat);
            const barR = new THREE.Mesh(new THREE.BoxGeometry(0.07, 2.6, 0.07), barMat);
            barL.position.set(-1.34, 1.48, i * 0.55);
            barR.position.set(1.34, 1.48, i * 0.55);
            this.jailGroup.add(barL, barR);
          }

          this.jailDoor = new THREE.Group();
          const doorFrame = new THREE.Mesh(new THREE.BoxGeometry(2.52, 2.6, 0.08), frameMat);
          doorFrame.position.set(0, 1.45, 0);
          this.jailDoor.add(doorFrame);
          for (let i = -2; i <= 2; i++) {
            const bar = new THREE.Mesh(new THREE.BoxGeometry(0.07, 2.4, 0.07), barMat);
            bar.position.set(i * 0.45, 1.45, 0.02);
            this.jailDoor.add(bar);
          }
          const lock = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.26, 0.1), new THREE.MeshLambertMaterial({ color: 0xf5cb5c }));
          lock.position.set(0.98, 1.3, -0.03);
          this.jailDoor.add(lock);
          this.jailDoor.position.set(-1.05, 0, -1.34);
          this.jailGroup.add(this.jailDoor);

          this.jailBeaconRedMat = new THREE.MeshLambertMaterial({ color: 0xff6a77, emissive: 0x6f141d, emissiveIntensity: 0.22 });
          this.jailBeaconBlueMat = new THREE.MeshLambertMaterial({ color: 0x66a3ff, emissive: 0x132e63, emissiveIntensity: 0.22 });
          const beaconBaseMat = new THREE.MeshLambertMaterial({ color: 0x1f2835 });
          const beaconGlowRedMat = new THREE.MeshBasicMaterial({ color: 0xff5e70, transparent: true, opacity: 0.25 });
          const beaconGlowBlueMat = new THREE.MeshBasicMaterial({ color: 0x5b93ff, transparent: true, opacity: 0.25 });

          const beaconBaseL = new THREE.Mesh(new THREE.CylinderGeometry(0.14, 0.14, 0.1, 12), beaconBaseMat);
          const beaconBaseR = beaconBaseL.clone();
          const beaconRed = new THREE.Mesh(new THREE.SphereGeometry(0.11, 12, 10), this.jailBeaconRedMat);
          const beaconBlue = new THREE.Mesh(new THREE.SphereGeometry(0.11, 12, 10), this.jailBeaconBlueMat);
          const beaconGlowRed = new THREE.Mesh(new THREE.SphereGeometry(0.18, 10, 8), beaconGlowRedMat);
          const beaconGlowBlue = new THREE.Mesh(new THREE.SphereGeometry(0.18, 10, 8), beaconGlowBlueMat);
          beaconBaseL.position.set(-0.56, 3.08, -1.0);
          beaconBaseR.position.set(0.56, 3.08, -1.0);
          beaconRed.position.set(-0.56, 3.17, -1.0);
          beaconBlue.position.set(0.56, 3.17, -1.0);
          beaconGlowRed.position.copy(beaconRed.position);
          beaconGlowBlue.position.copy(beaconBlue.position);
          this.jailGroup.add(beaconBaseL, beaconBaseR, beaconRed, beaconBlue, beaconGlowRed, beaconGlowBlue);
          this.jailBeaconRedGlow = beaconGlowRed;
          this.jailBeaconBlueGlow = beaconGlowBlue;

          this.jailRedLight = new THREE.PointLight(0xff4a5d, 0.35, 8.5, 1.8);
          this.jailBlueLight = new THREE.PointLight(0x4d7eff, 0.35, 8.5, 1.8);
          this.jailRedLight.position.set(-0.56, 3.18, -0.96);
          this.jailBlueLight.position.set(0.56, 3.18, -0.96);
          this.jailGroup.add(this.jailRedLight, this.jailBlueLight);

          this.jailRocketGroup = new THREE.Group();
          this.jailRocketGroup.visible = false;
          this.jailRocketFlames = [];
          this.jailRocketLights = [];
          const rocketNozzleMat = new THREE.MeshLambertMaterial({ color: 0x3a3f48 });
          const rocketRimMat = new THREE.MeshLambertMaterial({ color: 0x7b8793 });
          const flameTexture = this.makeRocketFlameSpriteTexture();
          const flameMat = new THREE.SpriteMaterial({
            map: flameTexture,
            color: 0xffffff,
            transparent: true,
            opacity: 0.9,
            depthWrite: false,
            depthTest: true,
            blending: THREE.AdditiveBlending
          });

          for (const x of [-0.95, 0.95]) {
            const nozzle = new THREE.Mesh(new THREE.CylinderGeometry(0.16, 0.2, 0.38, 14), rocketNozzleMat);
            nozzle.position.set(x, -0.14, 0.98);
            this.jailRocketGroup.add(nozzle);

            const rim = new THREE.Mesh(new THREE.TorusGeometry(0.16, 0.03, 8, 16), rocketRimMat);
            rim.rotation.x = Math.PI * 0.5;
            rim.position.set(x, -0.33, 0.98);
            this.jailRocketGroup.add(rim);

            const flame = new THREE.Sprite(flameMat.clone());
            flame.center.set(0.5, 0.92);
            flame.position.set(x, -0.46, 0.98);
            flame.scale.set(0.62, 0.86, 1);
            flame.userData.baseX = 0.62;
            flame.userData.baseY = 0.86;
            flame.userData.basePosY = -0.46;
            flame.userData.phase = rand(0, Math.PI * 2);
            flame.renderOrder = 33;
            this.jailRocketGroup.add(flame);
            this.jailRocketFlames.push(flame);

            const rocketLight = new THREE.PointLight(0xff8a40, 0, 5.8, 2.2);
            rocketLight.position.set(x, -0.66, 0.98);
            this.jailRocketGroup.add(rocketLight);
            this.jailRocketLights.push(rocketLight);
          }
          this.jailGroup.add(this.jailRocketGroup);

          this.nukeGroup = new THREE.Group();
          this.nukeGroup.visible = false;
          const nukeBodyMat = new THREE.MeshLambertMaterial({ color: 0x596571 });
          const nukeTipMat = new THREE.MeshLambertMaterial({ color: 0x2f3942 });
          const nukeStripeMat = new THREE.MeshLambertMaterial({ color: 0xd3b342 });
          const nukeFinMat = new THREE.MeshLambertMaterial({ color: 0x343d46 });
          const nukeBody = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 1.45, 16), nukeBodyMat);
          const nukeTip = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.34, 16), nukeTipMat);
          const nukeTail = new THREE.Mesh(new THREE.CylinderGeometry(0.24, 0.24, 0.14, 14), nukeTipMat);
          const nukeBand = new THREE.Mesh(new THREE.TorusGeometry(0.21, 0.03, 10, 18), nukeStripeMat);
          nukeTip.position.y = -0.9;
          nukeTail.position.y = 0.8;
          nukeBand.rotation.x = Math.PI * 0.5;
          nukeBand.position.y = 0.32;
          this.nukeGroup.add(nukeBody, nukeTip, nukeTail, nukeBand);
          for (const dir of [-1, 1]) {
            const fin = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.35, 0.24), nukeFinMat);
            fin.position.set(dir * 0.19, 0.72, 0);
            this.nukeGroup.add(fin);
          }
          for (const dir of [-1, 1]) {
            const fin = new THREE.Mesh(new THREE.BoxGeometry(0.24, 0.35, 0.05), nukeFinMat);
            fin.position.set(0, 0.72, dir * 0.19);
            this.nukeGroup.add(fin);
          }
          this.nukeGroup.position.set(0, 26, 34);
          this.nukeGroup.rotation.x = Math.PI;
          this.scene.add(this.nukeGroup);

          this.nukeImpactPoint = new THREE.Vector3(0, 0.5, 16.2);
          const shockMat = new THREE.MeshBasicMaterial({
            color: 0xffc878,
            transparent: true,
            opacity: 0,
            depthWrite: false,
            blending: THREE.AdditiveBlending
          });
          this.nukeShockwave = new THREE.Mesh(new THREE.SphereGeometry(1, 18, 14), shockMat);
          this.nukeShockwave.visible = false;
          this.nukeShockwave.position.copy(this.nukeImpactPoint);
          this.nukeShockwave.scale.set(0.35, 0.2, 0.35);
          this.scene.add(this.nukeShockwave);

          this.nukeFlashLight = new THREE.PointLight(0xffe8b0, 0, 38, 1.45);
          this.nukeFlashLight.position.copy(this.nukeImpactPoint);
          this.scene.add(this.nukeFlashLight);

          this.handcuffs = new THREE.Group();
          const cuffMat = new THREE.MeshLambertMaterial({ color: 0xb5bfc9 });
          const ringGeo = new THREE.TorusGeometry(0.13, 0.03, 8, 14);
          const cuffL = new THREE.Mesh(ringGeo, cuffMat);
          const cuffR = new THREE.Mesh(ringGeo, cuffMat);
          cuffL.rotation.y = Math.PI * 0.5;
          cuffR.rotation.y = Math.PI * 0.5;
          cuffL.position.x = -0.17;
          cuffR.position.x = 0.17;
          const chain = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.025, 0.24, 8), cuffMat);
          chain.rotation.z = Math.PI * 0.5;
          this.handcuffs.add(cuffL, cuffR, chain);
          this.handcuffs.visible = false;
          this.scene.add(this.handcuffs);

          this.copSpeechBubble = this.createSpeechBubbleSprite("Dad get liam a electric bike", 4.4, 1.3);
          this.playerSpeechBubble = this.createSpeechBubbleSprite("yes what he said", 4.15, 1.48);
          this.copSpeechBubble.renderOrder = 43;
          this.playerSpeechBubble.renderOrder = 42;
          this.copSpeechBubble.visible = false;
          this.playerSpeechBubble.visible = false;

          this.resetArrestScene();
        }

        createSpeechBubbleSprite(text, scaleX = 3, scaleY = 1.1) {
          const c = document.createElement("canvas");
          c.width = 768;
          c.height = 256;
          const g = c.getContext("2d");
          g.clearRect(0, 0, c.width, c.height);

          const pad = 24;
          const bubbleW = c.width - pad * 2;
          const bubbleH = c.height - 64;
          const bubbleX = pad;
          const bubbleY = 12;
          const r = 28;

          g.fillStyle = "rgba(255,255,255,0.94)";
          g.strokeStyle = "rgba(23,32,43,0.82)";
          g.lineWidth = 6;

          g.beginPath();
          g.moveTo(bubbleX + r, bubbleY);
          g.lineTo(bubbleX + bubbleW - r, bubbleY);
          g.quadraticCurveTo(bubbleX + bubbleW, bubbleY, bubbleX + bubbleW, bubbleY + r);
          g.lineTo(bubbleX + bubbleW, bubbleY + bubbleH - r);
          g.quadraticCurveTo(bubbleX + bubbleW, bubbleY + bubbleH, bubbleX + bubbleW - r, bubbleY + bubbleH);
          g.lineTo(bubbleX + bubbleW * 0.58, bubbleY + bubbleH);
          g.lineTo(bubbleX + bubbleW * 0.5, bubbleY + bubbleH + 42);
          g.lineTo(bubbleX + bubbleW * 0.42, bubbleY + bubbleH);
          g.lineTo(bubbleX + r, bubbleY + bubbleH);
          g.quadraticCurveTo(bubbleX, bubbleY + bubbleH, bubbleX, bubbleY + bubbleH - r);
          g.lineTo(bubbleX, bubbleY + r);
          g.quadraticCurveTo(bubbleX, bubbleY, bubbleX + r, bubbleY);
          g.closePath();
          g.fill();
          g.stroke();

          g.fillStyle = "#132033";
          g.font = "bold 56px Trebuchet MS, Arial Black, sans-serif";
          g.textAlign = "center";
          g.textBaseline = "middle";

          const maxWidth = bubbleW - 44;
          const words = text.split(" ");
          const lines = [];
          let cur = "";
          for (const word of words) {
            const next = cur ? `${cur} ${word}` : word;
            if (g.measureText(next).width <= maxWidth || cur.length === 0) {
              cur = next;
            } else {
              lines.push(cur);
              cur = word;
            }
          }
          if (cur) lines.push(cur);

          const lineHeight = 60;
          const startY = bubbleY + bubbleH * 0.5 - ((lines.length - 1) * lineHeight) * 0.5;
          lines.forEach((line, i) => {
            g.fillText(line, bubbleX + bubbleW * 0.5, startY + i * lineHeight);
          });

          const texture = new THREE.CanvasTexture(c);
          texture.needsUpdate = true;
          const material = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            depthTest: false,
            depthWrite: false
          });
          const sprite = new THREE.Sprite(material);
          sprite.scale.set(scaleX, scaleY, 1);
          sprite.renderOrder = 40;
          this.scene.add(sprite);
          return sprite;
        }

        resetArrestScene() {
          this.deathSeqTime = 0;
          this.deathCuffed = false;
          this.deathKickStarted = false;
          this.deathKickStartX = 0;
          this.deathKickStartZ = 0;
          this.deathDoorSlammed = false;
          this.deathCellImpactDone = false;
          this.deathRocketIgnited = false;
          this.deathNukeDropped = false;
          this.deathNukeExploded = false;
          this.jailGroup.visible = false;
          this.jailGroup.position.set(0, -5.8, 18.4);
          this.jailGroup.scale.set(1, 1, 1);
          this.jailGroup.rotation.set(0, 0, 0);
          this.jailDoor.position.x = -1.05;
          this.handcuffs.visible = false;
          if (this.copSpeechBubble) {
            this.copSpeechBubble.visible = false;
            this.copSpeechBubble.scale.set(4.4, 1.3, 1);
          }
          if (this.playerSpeechBubble) {
            this.playerSpeechBubble.visible = false;
            this.playerSpeechBubble.scale.set(4.15, 1.48, 1);
          }
          if (this.jailBeaconRedMat) this.jailBeaconRedMat.emissiveIntensity = 0.22;
          if (this.jailBeaconBlueMat) this.jailBeaconBlueMat.emissiveIntensity = 0.22;
          if (this.jailBeaconRedGlow) this.jailBeaconRedGlow.material.opacity = 0.25;
          if (this.jailBeaconBlueGlow) this.jailBeaconBlueGlow.material.opacity = 0.25;
          if (this.jailRedLight) this.jailRedLight.intensity = 0.35;
          if (this.jailBlueLight) this.jailBlueLight.intensity = 0.35;
          if (this.jailRocketGroup) this.jailRocketGroup.visible = false;
          if (this.jailRocketFlames) {
            for (const flame of this.jailRocketFlames) {
              flame.position.y = flame.userData.basePosY ?? -0.46;
              flame.scale.set(flame.userData.baseX ?? 0.62, flame.userData.baseY ?? 0.86, 1);
              flame.material.opacity = 0.9;
              flame.material.rotation = 0;
            }
          }
          if (this.jailRocketLights) {
            for (const light of this.jailRocketLights) light.intensity = 0;
          }
          if (this.nukeGroup) {
            this.nukeGroup.visible = false;
            this.nukeGroup.position.set(0, 26, 34);
            this.nukeGroup.rotation.set(Math.PI, 0, 0);
          }
          if (this.nukeShockwave) {
            this.nukeShockwave.visible = false;
            this.nukeShockwave.scale.set(0.35, 0.2, 0.35);
            this.nukeShockwave.material.opacity = 0;
            if (this.nukeImpactPoint) this.nukeShockwave.position.copy(this.nukeImpactPoint);
          }
          if (this.nukeFlashLight) {
            this.nukeFlashLight.intensity = 0;
            if (this.nukeImpactPoint) this.nukeFlashLight.position.copy(this.nukeImpactPoint);
          }
          this.resetMapBlastVisuals();
        }

        setupCopBoostSystem() {
          this.copBoosts = [];
          this.copBoostPool = [];
          this.copBoostSpawnTimer = rand(4.8, 7.4);
          this.copBoostTimer = 0;
        }

        createCopBoost() {
          const group = new THREE.Group();
          const ring = new THREE.Mesh(
            new THREE.TorusGeometry(0.28, 0.05, 10, 22),
            new THREE.MeshLambertMaterial({ color: 0x4cf095, emissive: 0x124d2f, emissiveIntensity: 0.5 })
          );
          ring.rotation.x = Math.PI * 0.5;
          const core = new THREE.Mesh(
            new THREE.OctahedronGeometry(0.18, 0),
            new THREE.MeshLambertMaterial({ color: 0xd8fff0, emissive: 0x2f9070, emissiveIntensity: 0.65 })
          );
          const glow = new THREE.Mesh(
            new THREE.SphereGeometry(0.22, 10, 9),
            new THREE.MeshBasicMaterial({ color: 0x83ffd0, transparent: true, opacity: 0.3 })
          );
          group.add(ring, core, glow);
          group.visible = false;
          this.scene.add(group);
          return { mesh: group, z: 0, lane: 1, phase: rand(0, Math.PI * 2) };
        }

        acquireCopBoost() {
          return this.copBoostPool.pop() || this.createCopBoost();
        }

        releaseCopBoost(boost) {
          boost.mesh.visible = false;
          this.copBoostPool.push(boost);
        }

        clearCopBoosts() {
          for (let i = this.copBoosts.length - 1; i >= 0; i--) {
            this.releaseCopBoost(this.copBoosts[i]);
          }
          this.copBoosts.length = 0;
          this.copBoostSpawnTimer = rand(4.8, 7.4);
        }

        spawnCopBoost(z = rand(46, 102)) {
          const lane = randInt(0, 2);
          const b = this.acquireCopBoost();
          b.lane = lane;
          b.z = z;
          b.phase = rand(0, Math.PI * 2);
          b.mesh.position.set(CONFIG.lanePositions[lane], 1.18, z);
          b.mesh.rotation.set(0, rand(0, Math.PI * 2), 0);
          b.mesh.visible = true;
          this.copBoosts.push(b);
        }

        updateCopBoosts(dt, worldSpeed, time) {
          this.copBoostSpawnTimer -= dt;
          if (this.copBoostSpawnTimer <= 0) {
            this.spawnCopBoost();
            this.copBoostSpawnTimer = rand(4.4, 8.1);
          }

          for (let i = this.copBoosts.length - 1; i >= 0; i--) {
            const b = this.copBoosts[i];
            b.z -= worldSpeed * dt;
            b.mesh.position.z = b.z;
            b.mesh.position.y = 1.18 + Math.sin(time * 5 + b.phase) * 0.16;
            b.mesh.rotation.y += dt * 3.8;
            if (b.z < CONFIG.despawnZ - 4) {
              this.releaseCopBoost(b);
              this.copBoosts.splice(i, 1);
            }
          }
        }

        checkCopBoostCollisions() {
          const pos = this.chaser.group.position;
          const py = this.chaser.jumpY + 0.9;
          for (let i = this.copBoosts.length - 1; i >= 0; i--) {
            const b = this.copBoosts[i];
            const dx = b.mesh.position.x - pos.x;
            const dy = b.mesh.position.y - py;
            const dz = b.z;
            if (dx * dx + dy * dy + dz * dz < 1.2) {
              this.copBoostTimer = Math.min(6.5, this.copBoostTimer + 3.0);
              this.particles.emitCoinBurst(b.mesh.position, 11);
              this.releaseCopBoost(b);
              this.copBoosts.splice(i, 1);
            }
          }
        }

        setupRunnerPowerUpSystem() {
          this.runnerPowerUps = [];
          this.runnerPowerUpPool = { magnet: [], sneakers: [], hoverboard: [] };
          this.runnerPowerUpSpawnTimer = rand(7.0, 10.8);
          this.activeRunnerPowerUps = { magnet: 0, sneakers: 0, hoverboard: 0 };
        }

        pickRunnerPowerUpType() {
          const roll = Math.random();
          if (roll < 0.37) return "magnet";
          if (roll < 0.7) return "sneakers";
          return "hoverboard";
        }

        createRunnerPowerUp(type) {
          const group = new THREE.Group();

          if (type === "magnet") {
            const mat = new THREE.MeshLambertMaterial({ color: 0xff6c6c, emissive: 0x5a1f1f, emissiveIntensity: 0.52 });
            const left = new THREE.Mesh(new THREE.BoxGeometry(0.13, 0.45, 0.13), mat);
            const right = new THREE.Mesh(new THREE.BoxGeometry(0.13, 0.45, 0.13), mat);
            left.position.x = -0.15;
            right.position.x = 0.15;
            const bridge = new THREE.Mesh(
              new THREE.TorusGeometry(0.15, 0.048, 10, 18, Math.PI),
              new THREE.MeshLambertMaterial({ color: 0xffb0b0, emissive: 0x512626, emissiveIntensity: 0.44 })
            );
            bridge.rotation.z = Math.PI;
            bridge.position.y = 0.17;
            group.add(left, right, bridge);
          } else if (type === "sneakers") {
            const shoe = new THREE.Mesh(
              new THREE.BoxGeometry(0.4, 0.14, 0.24),
              new THREE.MeshLambertMaterial({ color: 0x8af3ff, emissive: 0x1a6875, emissiveIntensity: 0.58 })
            );
            shoe.rotation.y = Math.PI * 0.22;
            const sole = new THREE.Mesh(
              new THREE.BoxGeometry(0.42, 0.05, 0.27),
              new THREE.MeshLambertMaterial({ color: 0xf7f9ff })
            );
            sole.position.y = -0.09;
            sole.rotation.y = shoe.rotation.y;
            const wingL = new THREE.Mesh(new THREE.PlaneGeometry(0.16, 0.1), new THREE.MeshBasicMaterial({ color: 0xd4ffff, transparent: true, opacity: 0.84, side: THREE.DoubleSide }));
            const wingR = wingL.clone();
            wingL.position.set(-0.12, 0.02, -0.14);
            wingR.position.set(0.14, 0.02, 0.11);
            wingL.rotation.y = Math.PI * 0.35;
            wingR.rotation.y = -Math.PI * 0.35;
            group.add(shoe, sole, wingL, wingR);
          } else {
            const board = new THREE.Mesh(
              new THREE.BoxGeometry(0.58, 0.06, 0.3),
              new THREE.MeshLambertMaterial({ color: 0xffcc58, emissive: 0x6a4a0f, emissiveIntensity: 0.45 })
            );
            const top = new THREE.Mesh(
              new THREE.BoxGeometry(0.5, 0.02, 0.22),
              new THREE.MeshLambertMaterial({ color: 0x3a84ff, emissive: 0x1d3f7d, emissiveIntensity: 0.56 })
            );
            top.position.y = 0.05;
            const glow = new THREE.Mesh(
              new THREE.RingGeometry(0.18, 0.28, 20),
              new THREE.MeshBasicMaterial({ color: 0x7adfff, transparent: true, opacity: 0.35, side: THREE.DoubleSide })
            );
            glow.rotation.x = Math.PI * 0.5;
            glow.position.y = -0.02;
            group.add(board, top, glow);
          }

          const halo = new THREE.Mesh(
            new THREE.TorusGeometry(0.3, 0.02, 8, 24),
            new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.28 })
          );
          halo.rotation.x = Math.PI * 0.5;
          halo.position.y = -0.18;
          group.add(halo);

          group.visible = false;
          this.scene.add(group);
          return { mesh: group, type, z: 0, lane: 1, phase: rand(0, Math.PI * 2), spin: rand(1.5, 3.8) };
        }

        acquireRunnerPowerUp(type) {
          const pool = this.runnerPowerUpPool[type] || (this.runnerPowerUpPool[type] = []);
          return pool.pop() || this.createRunnerPowerUp(type);
        }

        releaseRunnerPowerUp(powerUp) {
          powerUp.mesh.visible = false;
          const pool = this.runnerPowerUpPool[powerUp.type] || (this.runnerPowerUpPool[powerUp.type] = []);
          pool.push(powerUp);
        }

        clearRunnerPowerUps() {
          for (let i = this.runnerPowerUps.length - 1; i >= 0; i--) {
            this.releaseRunnerPowerUp(this.runnerPowerUps[i]);
          }
          this.runnerPowerUps.length = 0;
          this.runnerPowerUpSpawnTimer = rand(7.0, 10.8);
          this.activeRunnerPowerUps.magnet = 0;
          this.activeRunnerPowerUps.sneakers = 0;
          this.activeRunnerPowerUps.hoverboard = 0;
        }

        spawnRunnerPowerUp(z = rand(52, 110)) {
          const type = this.pickRunnerPowerUpType();
          const lane = randInt(0, 2);
          const p = this.acquireRunnerPowerUp(type);
          p.type = type;
          p.lane = lane;
          p.z = z;
          p.phase = rand(0, Math.PI * 2);
          p.spin = rand(1.5, 3.8);
          p.mesh.position.set(CONFIG.lanePositions[lane], 1.22, z);
          p.mesh.rotation.set(0, rand(0, Math.PI * 2), 0);
          p.mesh.visible = true;
          this.runnerPowerUps.push(p);
        }

        updateRunnerPowerUpTimers(dt) {
          this.activeRunnerPowerUps.magnet = Math.max(0, this.activeRunnerPowerUps.magnet - dt);
          this.activeRunnerPowerUps.sneakers = Math.max(0, this.activeRunnerPowerUps.sneakers - dt);
          this.activeRunnerPowerUps.hoverboard = Math.max(0, this.activeRunnerPowerUps.hoverboard - dt);
        }

        updateRunnerPowerUps(dt, worldSpeed, time) {
          this.runnerPowerUpSpawnTimer -= dt;
          if (this.distance > 100 && this.runnerPowerUpSpawnTimer <= 0) {
            this.spawnRunnerPowerUp();
            this.runnerPowerUpSpawnTimer = rand(7.2, 11.8);
          }

          for (let i = this.runnerPowerUps.length - 1; i >= 0; i--) {
            const p = this.runnerPowerUps[i];
            p.z -= worldSpeed * dt;
            p.mesh.position.z = p.z;
            p.mesh.position.y = 1.22 + Math.sin(time * 4.3 + p.phase) * 0.18;
            p.mesh.rotation.y += dt * p.spin;
            if (p.z < CONFIG.despawnZ - 5) {
              this.releaseRunnerPowerUp(p);
              this.runnerPowerUps.splice(i, 1);
            }
          }
        }

        activateRunnerPowerUp(type) {
          if (type === "magnet") this.activeRunnerPowerUps.magnet = Math.max(this.activeRunnerPowerUps.magnet, 10);
          if (type === "sneakers") this.activeRunnerPowerUps.sneakers = Math.max(this.activeRunnerPowerUps.sneakers, 9);
          if (type === "hoverboard") this.activeRunnerPowerUps.hoverboard = Math.max(this.activeRunnerPowerUps.hoverboard, 12);
          this.logEvent("runner-powerup", {
            type,
            magnet: Number(this.activeRunnerPowerUps.magnet.toFixed(2)),
            sneakers: Number(this.activeRunnerPowerUps.sneakers.toFixed(2)),
            hoverboard: Number(this.activeRunnerPowerUps.hoverboard.toFixed(2))
          });
        }

        checkRunnerPowerUpCollisions() {
          const pos = this.player.group.position;
          const py = this.player.jumpY + 0.9;
          for (let i = this.runnerPowerUps.length - 1; i >= 0; i--) {
            const p = this.runnerPowerUps[i];
            const dx = p.mesh.position.x - pos.x;
            const dy = p.mesh.position.y - py;
            const dz = p.z;
            if (dx * dx + dy * dy + dz * dz < 1.2) {
              this.activateRunnerPowerUp(p.type);
              this.particles.emitCoinBurst(p.mesh.position, 13);
              this.releaseRunnerPowerUp(p);
              this.runnerPowerUps.splice(i, 1);
            }
          }
        }

        getRunnerCoinPickupRadius() {
          if (this.playMode !== "runner") return 1.0;
          let radius = this.characterAbility?.coinRadius || 1.0;
          if (this.activeRunnerPowerUps.magnet > 0) radius = Math.max(radius, 4.6);
          return radius;
        }

        getRunnerJumpScale() {
          const base = this.characterAbility?.jumpScale || 1;
          if (this.activeRunnerPowerUps.sneakers > 0) return base + 0.45;
          return base;
        }

        parseAutoFunValue(value) {
          if (typeof value === "string") {
            const v = value.trim().toLowerCase();
            if (v === "true" || v === "1" || v === "on" || v === "yes") return true;
            if (v === "false" || v === "0" || v === "off" || v === "no") return false;
          }
          return !!value;
        }

        parseSpeedValue(value) {
          let raw = value;
          if (raw && typeof raw === "object") {
            if (Number.isFinite(raw.value)) raw = raw.value;
            else if (Number.isFinite(raw.multiplier)) raw = raw.multiplier;
          }
          if (typeof raw === "string") {
            const cleaned = raw.trim().replace(/[{}]/g, "");
            if (cleaned.length > 0) raw = cleaned;
          }
          const n = Number(raw);
          if (!Number.isFinite(n) || n <= 0) return null;
          return clamp(n, 0.1, 80);
        }

        applySpeedMultiplierImmediate(parsed, source = "console") {
          const prev = this.speedMultiplier;
          this.speedMultiplier = parsed;
          this.telemetryLogTimer = 0;
          this.autoBotDecisionTimer = 0;

          if (this.state === "playing") {
            const mult = this.playMode === "runner" ? this.getRunnerSpeedMultiplier() : this.getGlobalSpeedMultiplier();
            this.logEvent("speed-live", {
              source,
              mode: this.playMode,
              speedMultiplier: Number(this.speedMultiplier.toFixed(2)),
              effectiveWorldMultiplier: Number(mult.toFixed(2))
            });
          }

          this.logEvent("speed-set", {
            source,
            previous: Number((prev ?? 1).toFixed(2)),
            Speed: Number(this.speedMultiplier.toFixed(2)),
            autoFunTopSpeed: Number((this.speedMultiplier * this.autoFunSpeedOverdrive).toFixed(2)),
            autoFunInputMultiplier: Number(this.getAutoRunnerInputMultiplier().toFixed(2))
          });
        }

        logEvent(tag, payload = null) {
          if (!this.debugLoggingEnabled) return;
          const stamp = (performance.now() * 0.001).toFixed(3);
          if (payload == null) {
            console.log(`[game ${stamp}] ${tag}`);
            return;
          }
          console.log(`[game ${stamp}] ${tag}`, payload);
        }

        getGlobalSpeedMultiplier() {
          return Math.max(0.1, this.speedMultiplier || 1);
        }

        getRunnerSpeedMultiplier() {
          const base = this.getGlobalSpeedMultiplier();
          if (!this.autoRunnerActive) return base;
          return Math.max(base * this.autoFunSpeedOverdrive, base + 1.25);
        }

        getAutoRunnerInputMultiplier() {
          const global = this.getGlobalSpeedMultiplier();
          const autoOverdrive = this.autoRunnerActive ? this.autoFunSpeedOverdrive : 1;
          return clamp(global * autoOverdrive, 0.2, 400);
        }

        updateRuntimeTelemetry(dt, worldSpeed) {
          if (!this.debugLoggingEnabled || this.state !== "playing") return;
          this.telemetryLogTimer -= dt;
          if (this.telemetryLogTimer > 0) return;
          this.telemetryLogTimer = this.telemetryLogInterval;
          this.logEvent("telemetry", {
            state: this.state,
            mode: this.playMode,
            speed: Number(worldSpeed.toFixed(2)),
            baseSpeed: Number(this.speed.toFixed(2)),
            speedMultiplier: Number(this.getGlobalSpeedMultiplier().toFixed(2)),
            autoFunSpeedMultiplier: Number(this.getRunnerSpeedMultiplier().toFixed(2)),
            autoFunInputMultiplier: Number(this.getAutoRunnerInputMultiplier().toFixed(2)),
            distance: Math.floor(this.distance),
            coins: this.runCoins,
            score: this.score,
            autoRunner: this.autoRunnerActive
          });
        }

        isAutoFunGodMode() {
          return this.playMode === "runner" && this.autoFunEnabled;
        }

        installAutoFunConsoleControls() {
          if (typeof window.True === "undefined") window.True = true;
          if (typeof window.False === "undefined") window.False = false;

          const autoFunSetter = (value) => {
            const enabled = this.parseAutoFunValue(value);
            this.autoFunEnabled = enabled;
            if (!enabled) {
              this.autoRunnerPending = false;
              this.autoRunnerActive = false;
            }
            this.logEvent("autofun-toggle", { enabled });
          };

          const speedSetter = (value) => {
            const parsed = this.parseSpeedValue(value);
            if (parsed == null) {
              console.warn(`[Speed] Invalid value: ${value}. Use positive numbers like Speed=1.5`);
              return;
            }
            this.applySpeedMultiplierImmediate(parsed, "console");
          };

          const loggingSetter = (value) => {
            this.debugLoggingEnabled = this.parseAutoFunValue(value);
            const msg = this.debugLoggingEnabled ? "enabled" : "disabled";
            console.info(`[logging] ${msg}`);
          };

          const defineToggleProp = (name, getter, setter) => {
            const existing = Object.getOwnPropertyDescriptor(window, name);
            if (existing && !existing.configurable) return;
            Object.defineProperty(window, name, {
              configurable: true,
              enumerable: false,
              get: getter,
              set: setter
            });
          };

          defineToggleProp("autofun", () => this.autoFunEnabled, autoFunSetter);
          defineToggleProp("autoFun", () => this.autoFunEnabled, autoFunSetter);
          defineToggleProp("Speed", () => this.speedMultiplier, speedSetter);
          defineToggleProp("speedMultiplier", () => this.speedMultiplier, speedSetter);
          window.setSpeed = (value) => {
            const parsed = this.parseSpeedValue(value);
            if (parsed == null) {
              console.warn(`[setSpeed] Invalid value: ${value}. Use numbers like setSpeed(2.5)`);
              return this.speedMultiplier;
            }
            this.applySpeedMultiplierImmediate(parsed, "setSpeed()");
            return this.speedMultiplier;
          };
          defineToggleProp("logging", () => this.debugLoggingEnabled, loggingSetter);
          defineToggleProp("logAll", () => this.debugLoggingEnabled, loggingSetter);
          this.logEvent("console-commands-ready", {
            commands: ["autofun", "autoFun", "Speed", "speedMultiplier", "setSpeed()", "logging", "logAll"]
          });
        }

        getAutoRunnerLaneThreatScore(lane) {
          const laneX = CONFIG.lanePositions[lane];
          let score = 0;
          for (const o of this.obstacleManager.active) {
            if (!o.collidable || o.airborne) continue;
            const front = o.z - o.d * 0.5;
            if (front < 0.12 || front > 9.2) continue;
            const xOverlap = Math.abs(o.x - laneX) * 2 < (o.w + 0.9);
            if (!xOverlap) continue;

            const danger = 1 / Math.max(0.35, front);
            if (o.kind === "full_block" || o.kind === "lane_block") score += 11 * danger;
            else if (o.kind === "slide" || o.kind === "jump") score += 4.6 * danger;
            else score += 2.2 * danger;
          }
          return score;
        }

        getAutoRunnerCoinLaneScore(lane, pickupRadius = 1.0) {
          const laneX = CONFIG.lanePositions[lane];
          let score = 0;
          for (const c of this.coinManager.active) {
            const front = c.z;
            if (front < 0.08 || front > 13.5) continue;

            const dx = Math.abs(c.mesh.position.x - laneX);
            if (dx > pickupRadius + 0.18) continue;

            const coinY = Number.isFinite(c.baseY) ? c.baseY : c.mesh.position.y;
            let value = 1 / (0.55 + front * 0.26);
            if (front < 3.2) value *= 1.35;
            if (coinY > 1.85 || coinY < 0.82) value *= 1.18;
            score += value;
          }
          return score;
        }

        tryAutoRunnerCoinPoseAdjust(currentLane, pickupRadius, blockedByObstacle) {
          if (blockedByObstacle) return;
          if (this.player.isJumping || this.player.isSliding) return;

          const laneX = CONFIG.lanePositions[currentLane];
          const alignLimit = Math.max(0.55, pickupRadius * 0.72);
          let targetCoin = null;
          let nearestFront = Infinity;

          for (const c of this.coinManager.active) {
            const front = c.z;
            if (front < 0.22 || front > 3.2) continue;

            const dx = Math.abs(c.mesh.position.x - laneX);
            if (dx > alignLimit) continue;

            if (front < nearestFront) {
              nearestFront = front;
              targetCoin = c;
            }
          }

          if (!targetCoin) return;

          const coinY = Number.isFinite(targetCoin.baseY) ? targetCoin.baseY : targetCoin.mesh.position.y;
          if (coinY > 1.7) {
            if (this.player.jump()) this.logEvent("autofun-wasd", { key: "W", reason: "high-coin", z: Number(targetCoin.z.toFixed(2)) });
          } else if (coinY < 0.82) {
            if (this.player.slide()) this.logEvent("autofun-wasd", { key: "S", reason: "low-coin", z: Number(targetCoin.z.toFixed(2)) });
          }
        }

        updateAutoRunner(dt) {
          if (!this.autoRunnerActive || this.state !== "playing" || this.playMode !== "runner") return;

          this.autoBotDecisionTimer = Math.max(0, this.autoBotDecisionTimer - dt);
          const currentLane = this.player.targetLane;
          const laneX = CONFIG.lanePositions[currentLane];
          const pickupRadius = this.getRunnerCoinPickupRadius();
          const inputMult = this.getAutoRunnerInputMultiplier();
          const lookAhead = 6.8 + Math.min(26, inputMult * 0.6);
          const jumpWindow = 3.3 + Math.min(5.5, inputMult * 0.18);
          const slideWindow = 3.0 + Math.min(4.8, inputMult * 0.16);
          const urgentWindow = 4.9 + Math.min(8.5, inputMult * 0.24);
          let urgentBlock = false;
          let obstacleActionTriggered = false;

          for (const o of this.obstacleManager.active) {
            if (!o.collidable || o.airborne) continue;
            const front = o.z - o.d * 0.5;
            if (front < 0.1 || front > lookAhead) continue;
            const xOverlap = Math.abs(o.x - laneX) * 2 < (o.w + 0.92);
            if (!xOverlap) continue;

            if (o.kind === "jump" && front < jumpWindow) {
              const didJump = this.player.jump();
              obstacleActionTriggered = didJump || obstacleActionTriggered;
              if (didJump) this.logEvent("autofun-wasd", { key: "W", reason: "jump-obstacle", obstacle: o.type, z: Number(front.toFixed(2)) });
            }
            if (o.kind === "slide" && front < slideWindow) {
              const didSlide = this.player.slide();
              obstacleActionTriggered = didSlide || obstacleActionTriggered;
              if (didSlide) this.logEvent("autofun-wasd", { key: "S", reason: "slide-obstacle", obstacle: o.type, z: Number(front.toFixed(2)) });
            }
            if ((o.kind === "lane_block" || o.kind === "full_block") && front < urgentWindow) urgentBlock = true;
          }

          this.tryAutoRunnerCoinPoseAdjust(currentLane, pickupRadius, obstacleActionTriggered);

          if (!urgentBlock && this.autoBotDecisionTimer > 0) return;

          const laneStats = [0, 1, 2].map((lane) => {
            const threat = this.getAutoRunnerLaneThreatScore(lane);
            const coins = this.getAutoRunnerCoinLaneScore(lane, pickupRadius);
            const laneShiftPenalty = Math.abs(lane - currentLane) * 0.25;
            const utility = coins * 3.6 - threat * 4.2 - laneShiftPenalty;
            return { lane, threat, coins, utility };
          });

          const currentStat = laneStats.find((s) => s.lane === currentLane) || laneStats[1];
          let targetLane = currentLane;

          if (urgentBlock) {
            laneStats.sort((a, b) => {
              if (Math.abs(a.threat - b.threat) > 0.08) return a.threat - b.threat;
              if (Math.abs(a.utility - b.utility) > 0.12) return b.utility - a.utility;
              return b.coins - a.coins;
            });
            targetLane = laneStats[0].lane;
          } else {
            laneStats.sort((a, b) => b.utility - a.utility);
            const best = laneStats[0];
            const gain = best.utility - currentStat.utility;
            if (gain > 0.26) targetLane = best.lane;
          }

          if (targetLane !== this.player.targetLane) {
            const prevTargetLane = this.player.targetLane;
            const dir = targetLane > prevTargetLane ? 1 : -1;
            if (this.player.queueLane(dir)) {
              this.logEvent("autofun-wasd", { key: dir > 0 ? "D" : "A", fromLane: prevTargetLane, toLane: this.player.targetLane, urgent: urgentBlock });
            }
          }

          const baseDecision = urgentBlock ? rand(0.015, 0.045) : rand(0.02, 0.06);
          this.autoBotDecisionTimer = Math.max(0.0015, baseDecision / Math.max(1, Math.sqrt(inputMult)));
        }

        getFugitiveLaneThreatScore(lane) {
          const laneX = CONFIG.lanePositions[lane];
          let score = 0;
          for (const o of this.obstacleManager.active) {
            if (!o.collidable || o.airborne) continue;
            const rel = o.z - this.fugitiveLead;
            if (rel < 0.45 || rel > 6.6) continue;
            const xOverlap = Math.abs(o.x - laneX) * 2 < (o.w + 0.84);
            if (!xOverlap) continue;
            if (o.kind === "full_block" || o.kind === "lane_block") score += 5;
            else if (o.kind === "slide" || o.kind === "jump") score += 2;
            else score += 1;
          }
          return score;
        }

        updateFugitiveAI(dt) {
          this.fugitiveDecisionTimer -= dt;
          const currentLane = this.player.targetLane;
          const laneX = CONFIG.lanePositions[currentLane];
          let urgentBlock = false;

          for (const o of this.obstacleManager.active) {
            if (!o.collidable || o.airborne) continue;
            const rel = o.z - this.fugitiveLead;
            if (rel < 0.15 || rel > 5.4) continue;
            const xOverlap = Math.abs(o.x - laneX) * 2 < (o.w + 0.88);
            if (!xOverlap) continue;

            if (o.kind === "jump" && rel < 3.2) this.player.jump();
            if (o.kind === "slide" && rel < 2.75) this.player.slide();
            if ((o.kind === "lane_block" || o.kind === "full_block") && rel < 4.2) urgentBlock = true;
          }

          if (!urgentBlock && this.fugitiveDecisionTimer > 0) return;

          const scores = [0, 1, 2].map((lane) => ({ lane, score: this.getFugitiveLaneThreatScore(lane) }));
          scores.sort((a, b) => a.score - b.score);
          let targetLane = scores[0].lane;
          if (!urgentBlock && Math.random() < 0.18) targetLane = randInt(0, 2);

          if (targetLane !== this.player.targetLane) {
            const dir = targetLane > this.player.targetLane ? 1 : -1;
            this.player.queueLane(dir);
          }

          this.fugitiveDecisionTimer = urgentBlock ? rand(0.22, 0.45) : rand(0.48, 0.95);
        }

        loadUnlockedCharacters() {
          const stored = safeReadJSON(CONFIG.storage.unlockedCharacters, ["jake"]);
          const arr = Array.isArray(stored) ? stored : ["jake"];
          const filtered = arr.filter((id) => typeof id === "string" && CHARACTER_BY_ID[id]);
          if (!filtered.includes("jake")) filtered.unshift("jake");
          return Array.from(new Set(filtered));
        }

        loadSelectedCharacterId() {
          const selected = safeReadString(CONFIG.storage.selectedCharacter, "jake");
          if (this.unlockedCharacterIds.includes(selected) && CHARACTER_BY_ID[selected]) return selected;
          return this.unlockedCharacterIds[0] || "jake";
        }

        saveCharacterState() {
          safeWriteJSON(CONFIG.storage.unlockedCharacters, this.unlockedCharacterIds);
          safeWriteString(CONFIG.storage.selectedCharacter, this.selectedCharacterId);
        }

        getCharacterById(id) {
          return CHARACTER_BY_ID[id] || CHARACTER_BY_ID.jake;
        }

        getSelectedCharacter() {
          return this.getCharacterById(this.selectedCharacterId);
        }

        getSelectedAbility() {
          return this.getSelectedCharacter().ability || buildAbilityFromPrice(0);
        }

        isCharacterUnlocked(id) {
          return this.unlockedCharacterIds.includes(id);
        }

        applySelectedCharacter() {
          const selected = this.getSelectedCharacter();
          this.characterAbility = selected.ability || buildAbilityFromPrice(0);
          this.player.setCharacter(selected);
          this.player.setAbilityModifiers(this.characterAbility);
          this.ui.updateMenuCharacter(selected.name);
          this.ui.updateShopMeta(this.totalCoins, selected.name);
        }

        selectCharacter(id) {
          if (!this.isCharacterUnlocked(id)) return false;
          this.selectedCharacterId = id;
          this.applySelectedCharacter();
          this.saveCharacterState();
          this.renderShop();
          this.logEvent("character-selected", { id });
          return true;
        }

        buyCharacter(id) {
          const character = this.getCharacterById(id);
          if (this.isCharacterUnlocked(id)) return this.selectCharacter(id);
          if (this.totalCoins < character.price) return false;

          this.totalCoins -= character.price;
          this.unlockedCharacterIds.push(id);
          this.unlockedCharacterIds = Array.from(new Set(this.unlockedCharacterIds));
          safeWriteInt(CONFIG.storage.totalCoins, this.totalCoins);
          this.selectedCharacterId = id;
          this.applySelectedCharacter();
          this.saveCharacterState();
          this.renderShop();
          this.logEvent("character-bought", { id, price: character.price, coinsLeft: this.totalCoins });
          return true;
        }

        openShop() {
          if (this.state !== "menu") return;
          this.renderShop();
          this.ui.showShop(this.totalCoins, this.getSelectedCharacter().name);
          this.input.clear();
          this.logEvent("shop-open");
        }

        closeShop() {
          if (this.state !== "menu") return;
          this.ui.showMenu(this.highScore, this.totalCoins, this.getSelectedCharacter().name);
          this.input.clear();
          this.logEvent("shop-close");
        }

        renderShop() {
          const list = this.ui.shopList;
          if (!list) return;
          list.innerHTML = "";

          for (const character of CHARACTER_CATALOG) {
            const unlocked = this.isCharacterUnlocked(character.id);
            const selected = this.selectedCharacterId === character.id;
            const affordable = this.totalCoins >= character.price;
            const card = document.createElement("div");
            card.className = `shop-card${unlocked ? "" : " locked"}`;

            const name = document.createElement("div");
            name.className = "shop-name";
            name.textContent = character.name;

            const price = document.createElement("div");
            price.className = "shop-price";
            if (character.price === 0) {
              price.textContent = "Starter Character";
            } else if (unlocked) {
              price.textContent = "Owned";
            } else {
              price.textContent = `${formatInt(character.price)} coins`;
            }

            const ability = document.createElement("div");
            ability.className = "shop-ability";
            ability.textContent = `${character.ability.tierName}: ${character.ability.summary}`;

            const preview = document.createElement("div");
            preview.className = "shop-preview";
            const swatches = [
              character.skin.hoodie,
              character.skin.hoodieDark,
              character.skin.pants,
              character.skin.shoe,
              character.skin.hair
            ];
            for (const c of swatches) {
              const sw = document.createElement("span");
              sw.className = "shop-swatch";
              sw.style.background = `#${c.toString(16).padStart(6, "0")}`;
              preview.appendChild(sw);
            }

            const action = document.createElement("button");
            action.className = "shop-action";
            if (selected) {
              action.textContent = "Selected";
              action.classList.add("selected");
            } else if (unlocked) {
              action.textContent = "Select";
              action.classList.add("secondary");
            } else if (affordable) {
              action.textContent = `Buy ${formatInt(character.price)}`;
            } else {
              action.textContent = `Need ${formatInt(character.price - this.totalCoins)}`;
              action.classList.add("secondary");
              action.disabled = true;
              action.style.opacity = "0.72";
              action.style.cursor = "not-allowed";
            }

            if (!selected) {
              action.addEventListener("click", () => {
                if (unlocked) this.selectCharacter(character.id);
                else this.buyCharacter(character.id);
              });
            }

            card.appendChild(name);
            card.appendChild(price);
            card.appendChild(ability);
            card.appendChild(preview);
            card.appendChild(action);
            list.appendChild(card);
          }

          this.ui.updateMenuCoins(this.totalCoins);
          this.ui.updateMenuCharacter(this.getSelectedCharacter().name);
          this.ui.updateShopMeta(this.totalCoins, this.getSelectedCharacter().name);
        }

        bindUI() {
          this.ui.playBtn.addEventListener("click", () => {
            this.audio.unlockAudio();
            this.playMode = "runner";
            this.autoRunnerPending = this.autoFunEnabled;
            this.beginIntroCutscene();
          });
          this.ui.playCopBtn.addEventListener("click", () => {
            this.audio.unlockAudio();
            this.playMode = "cop";
            this.autoRunnerPending = false;
            this.startRun(false);
          });
          this.ui.shopBtn.addEventListener("click", () => this.openShop());
          this.ui.shopCloseBtn.addEventListener("click", () => this.closeShop());
          this.ui.retryBtn.addEventListener("click", () => {
            this.audio.unlockAudio();
            if (this.playMode === "cop") this.startRun(false);
            else {
              this.autoRunnerPending = this.autoFunEnabled;
              this.beginIntroCutscene();
            }
          });
          this.ui.retryCopBtn.addEventListener("click", () => {
            this.audio.unlockAudio();
            this.playMode = "cop";
            this.startRun(false);
          });
          this.ui.overMenuBtn.addEventListener("click", () => this.goToMenu());
          this.ui.pauseMenuBtn.addEventListener("click", () => this.goToMenu());
          this.ui.resumeBtn.addEventListener("click", () => this.resume());
          this.ui.pauseBtn.addEventListener("click", () => this.togglePause());
          this.ui.cutsceneSkip.addEventListener("click", () => this.skipCutscene());
        }

        onResize() {
          this.camera.aspect = window.innerWidth / window.innerHeight;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(window.innerWidth, window.innerHeight);
        }

        goToMenu() {
          this.state = "menu";
          this.logEvent("state-menu", {
            totalCoins: this.totalCoins,
            bestScore: this.highScore,
            speedMultiplier: this.speedMultiplier
          });
          this.distance = 0;
          this.speed = CONFIG.baseSpeed * 0.45;
          this.score = 0;
          this.runCoins = 0;
          this.shieldCharges = 0;
          this.isCopOutcome = false;
          this.copCaughtRunner = false;
          this.fugitiveLead = 5.2;
          this.fugitiveBurstTimer = 0;
          this.fugitiveSpeedBonus = 0;
          this.nextFugitiveBurst = rand(5.5, 10.0);
          this.fugitiveDecisionTimer = 0.65;
          this.copBoostTimer = 0;
          this.crashTimer = 0;
          this.wasOnTrainTop = false;
          this.autoRunnerActive = false;
          this.autoRunnerPending = false;
          this.shakeTime = 0;
          this.obstacleManager.reset();
          this.coinManager.clear();
          this.clearCopBoosts();
          this.clearRunnerPowerUps();
          this.particles.clear();
          this.player.reset();
          this.player.setAbilityModifiers(this.getSelectedAbility());
          this.player.group.visible = true;
          this.player.group.rotation.y = 0;
          this.chaser.reset();
          this.chaser.setVisible(false);
          this.chaser.resetActionState();
          this.cutsceneGroup.visible = false;
          this.cutsceneSpray.visible = false;
          this.resetArrestScene();
          this.ui.hideCutscene();
          this.audio.stopAll();
          this.ui.multiplier.textContent = "x2";
          this.renderShop();
          this.ui.showMenu(this.highScore, this.totalCoins, this.getSelectedCharacter().name);
          this.input.clear();
        }

        beginIntroCutscene() {
          if (this.state === "cutscene") return;
          this.state = "cutscene";
          this.logEvent("state-cutscene-start", {
            mode: this.playMode,
            autoRunnerPending: this.autoRunnerPending
          });
          this.cutsceneTime = 0;
          this.cutsceneWhistlePlayed = false;
          this.cutsceneStartedRun = false;
          this.cutsceneSkipRequested = false;

          this.distance = 0;
          this.speed = CONFIG.baseSpeed * 0.2;
          this.score = 0;
          this.runCoins = 0;
          this.shakeTime = 0;
          this.crashTimer = 0;
          this.wasOnTrainTop = false;
          this.autoRunnerActive = false;

          this.obstacleManager.reset();
          this.coinManager.clear();
          this.clearRunnerPowerUps();
          this.particles.clear();
          this.resetArrestScene();
          this.player.reset();
          this.player.group.position.set(-2.02, 0, 9.2);
          this.player.group.rotation.y = Math.PI * 0.5;
          this.player.visualRoot.rotation.set(-0.12, 0, 0);
          this.player.visualRoot.position.y = 0;
          this.player.laneLean = 0;
          this.player.runClock = 0;

          this.chaser.reset();
          this.chaser.setVisible(true);
          this.chaser.group.position.set(4.8, 0, 8.55);
          this.chaser.group.rotation.y = -Math.PI * 0.55;

          this.cutsceneGroup.visible = true;
          this.cutsceneGraffiti.material.opacity = 0;
          this.cutsceneSpray.visible = true;
          this.audio.stopAll();
          this.ui.showCutscene("Spray painting the train...");
          this.input.clear();
        }

        skipCutscene() {
          if (this.state !== "cutscene") return;
          this.cutsceneSkipRequested = true;
          this.logEvent("cutscene-skip-requested");
        }

        startRun(playStartWhistle = false) {
          this.state = "playing";
          this.distance = 0;
          this.speed = CONFIG.baseSpeed;
          this.score = 0;
          this.runCoins = 0;
          this.isCopOutcome = false;
          this.copCaughtRunner = false;
          this.fugitiveLead = 5.2;
          this.fugitiveBurstTimer = 0;
          this.fugitiveSpeedBonus = 0;
          this.nextFugitiveBurst = rand(5.8, 10.4);
          this.fugitiveDecisionTimer = 0.65;
          this.copBoostTimer = 0;
          this.copBoostSpawnTimer = rand(4.8, 7.4);
          this.shakeTime = 0;
          this.cameraDip = 0;
          this.crashTimer = 0;
          this.wasOnTrainTop = false;
          this.autoRunnerActive = this.playMode === "runner" && this.autoRunnerPending;
          this.autoRunnerPending = false;
          this.autoBotDecisionTimer = rand(0.08, 0.18);
          this.telemetryLogTimer = 0.05;
          this.characterAbility = this.getSelectedAbility();
          this.shieldCharges = this.playMode === "runner" ? this.characterAbility.shieldCharges : 0;
          this.obstacleManager.reset();
          this.coinManager.clear();
          this.clearCopBoosts();
          this.clearRunnerPowerUps();
          this.particles.clear();
          this.player.reset();
          this.player.setAbilityModifiers(this.playMode === "runner" ? this.characterAbility : { jumpScale: 1 });
          this.player.group.visible = true;
          this.player.group.rotation.y = 0;
          this.input.clear();
          this.cutsceneGroup.visible = false;
          this.cutsceneSpray.visible = false;
          this.resetArrestScene();
          this.ui.hideCutscene();
          this.chaser.reset();
          this.chaser.resetActionState();
          this.chaser.setVisible(true);

          if (this.playMode === "cop") {
            this.player.group.position.set(0, 0, this.fugitiveLead);
            this.player.group.rotation.y = 0;
            this.chaser.group.position.set(0, 0, 0);
            this.chaser.currentLane = 1;
            this.chaser.targetLane = 1;
            this.chaser.laneFromX = CONFIG.lanePositions[1];
            this.chaser.laneToX = CONFIG.lanePositions[1];
            this.chaser.laneElapsed = CONFIG.laneSwitchDuration;
            this.ui.multiplier.textContent = "GAP";
          } else {
            this.ui.multiplier.textContent = `x${(this.characterAbility?.scoreMultiplier || 1).toFixed(2)}`;
          }

          if (playStartWhistle) this.audio.playStartWhistle();
          this.audio.playMusic();
          this.ui.updateHUD(this.score, this.runCoins, this.distance);
          this.ui.showPlayingHUD();
          this.ui.pulseMultiplier(this.playMode === "cop");
          this.logEvent("state-playing-start", {
            mode: this.playMode,
            autoRunner: this.autoRunnerActive,
            speedMultiplier: this.speedMultiplier,
            runnerSpeedMultiplier: this.getRunnerSpeedMultiplier()
          });
        }

        pause() {
          if (this.state !== "playing") return;
          this.state = "paused";
          this.audio.pauseMusic();
          this.ui.showPaused();
          this.logEvent("state-paused");
        }

        resume() {
          if (this.state !== "paused") return;
          this.state = "playing";
          this.audio.playMusic();
          this.ui.hidePaused();
          this.input.clear();
          this.logEvent("state-resumed");
        }

        togglePause() {
          if (this.state === "playing") this.pause();
          else if (this.state === "paused") this.resume();
        }

        crash() {
          if (this.state !== "playing") return;
          if (this.isAutoFunGodMode()) {
            this.shakeTime = Math.max(this.shakeTime, 0.08);
            this.shakeAmp = Math.max(this.shakeAmp, 0.05);
            this.logEvent("crash-blocked-autofun", { distance: Math.floor(this.distance), coins: this.runCoins });
            return;
          }
          this.wasOnTrainTop = false;
          this.autoRunnerActive = false;
          if (this.playMode === "cop") {
            this.audio.pauseMusic();
            this.ui.flashCrash();
            this.audio.play("crash");
            this.isCopOutcome = true;
            this.copCaughtRunner = false;
            this.logEvent("crash-cop-mode", { distance: Math.floor(this.distance), score: this.score });
            this.finishRun("He Got Away");
            return;
          }
          this.state = "crashed";
          this.audio.pauseMusic();
          this.chaser.resetActionState();
          this.crashTimer = 10.0;
          this.deathSeqTime = 0;
          this.deathCuffed = false;
          this.deathKickStarted = false;
          this.deathDoorSlammed = false;
          this.deathCellImpactDone = false;
          this.deathRocketIgnited = false;
          this.deathNukeDropped = false;
          this.deathNukeExploded = false;
          this.deathKickStartX = this.player.group.position.x;
          this.deathKickStartZ = this.player.group.position.z;
          this.jailGroup.visible = true;
          this.jailGroup.position.set(0, -5.8, 18.4);
          this.jailGroup.rotation.set(0, 0, 0);
          this.jailDoor.position.x = -1.05;
          this.handcuffs.visible = false;
          if (this.nukeGroup) {
            this.nukeGroup.visible = false;
            this.nukeGroup.position.set(0, 26, 34);
            this.nukeGroup.rotation.set(Math.PI, 0, 0);
          }
          if (this.nukeShockwave) {
            this.nukeShockwave.visible = false;
            this.nukeShockwave.material.opacity = 0;
          }
          if (this.nukeFlashLight) this.nukeFlashLight.intensity = 0;
          this.resetMapBlastVisuals();
          this.player.crash();
          this.shakeTime = 0.35;
          this.shakeAmp = 0.22;
          this.ui.flashCrash();
          this.audio.play("crash");
          this.logEvent("crash-runner", { distance: Math.floor(this.distance), coins: this.runCoins, score: this.score });
        }

        finishRun(titleOverride = null) {
          this.autoRunnerActive = false;
          const newTotalCoins = this.totalCoins + this.runCoins;
          this.totalCoins = newTotalCoins;
          safeWriteInt(CONFIG.storage.totalCoins, this.totalCoins);

          const newBest = Math.max(this.highScore, this.score);
          const isNew = newBest > this.highScore;
          this.highScore = newBest;
          safeWriteInt(CONFIG.storage.bestScore, this.highScore);

          this.state = "gameover";
          this.audio.pauseMusic();
          this.logEvent("state-gameover", {
            title: titleOverride || "Game Over",
            score: this.score,
            distance: Math.floor(this.distance),
            runCoins: this.runCoins,
            best: this.highScore
          });
          this.ui.showGameOver({
            title: titleOverride || "Game Over",
            score: this.score,
            distance: this.distance,
            coins: this.runCoins,
            best: this.highScore,
            newRecord: isNew
          });
        }

        processInputs() {
          let action = this.input.consumeNext();
          while (action) {
            this.logEvent("input", { action, state: this.state, mode: this.playMode });
            if (action === "pause") {
              if (this.state === "playing") this.pause();
              else if (this.state === "paused") this.resume();
              action = this.input.consumeNext();
              continue;
            }

            if (this.state === "menu" || this.state === "gameover") {
              if (this.state === "menu" && this.ui.isShopOpen()) {
                action = this.input.consumeNext();
                continue;
              }
              if (action === "jump") {
                this.audio.unlockAudio();
                this.playMode = "runner";
                this.autoRunnerPending = this.autoFunEnabled;
                this.beginIntroCutscene();
              }
              action = this.input.consumeNext();
              continue;
            }

            if (this.state === "playing") {
              if (this.playMode === "cop") {
                if (action === "left") this.chaser.queueLane(1);
                if (action === "right") this.chaser.queueLane(-1);
                if (action === "jump") this.chaser.jump();
                if (action === "slide") this.chaser.slide();
              } else {
                if (action === "left") this.player.queueLane(1);
                if (action === "right") this.player.queueLane(-1);
                if (action === "jump") this.player.jump();
                if (action === "slide") this.player.slide();
              }
            }

            action = this.input.consumeNext();
          }
        }

        setCameraUprightLookAt(eyeX, eyeY, eyeZ, targetX, targetY, targetZ, roll = 0) {
          const eye = new THREE.Vector3(eyeX, eyeY, eyeZ);
          const target = new THREE.Vector3(targetX, targetY, targetZ);
          const up = new THREE.Vector3(0, 1, 0);
          const z = new THREE.Vector3().subVectors(eye, target).normalize();

          if (Math.abs(up.dot(z)) > 0.999) {
            z.x += 0.0001;
            z.normalize();
          }

          const x = new THREE.Vector3().crossVectors(up, z).normalize();
          const y = new THREE.Vector3().crossVectors(z, x).normalize();
          const basis = new THREE.Matrix4().makeBasis(x, y, z);

          this.camera.position.copy(eye);
          this.camera.quaternion.setFromRotationMatrix(basis);
          if (roll !== 0) this.camera.rotateZ(roll);
        }

        resetMapBlastVisuals() {
          if (!this.track) return;
          if (this.track.ground) this.track.ground.rotation.x = -Math.PI * 0.5;
          if (this.track.tieGroup) {
            this.track.tieGroup.position.y = 0;
            this.track.tieGroup.rotation.z = 0;
          }
          if (this.track.rails) {
            for (const rail of this.track.rails) rail.position.y = 0.05;
          }
          if (this.track.wallSegments) {
            for (const seg of this.track.wallSegments) {
              seg.position.y = 0;
              seg.rotation.x = 0;
              seg.rotation.z = 0;
            }
          }

          const restoreBuildings = (list) => {
            if (!list) return;
            for (const b of list) {
              if (!b.userData) b.userData = {};
              if (b.userData.nukeBaseY !== undefined) b.position.y = b.userData.nukeBaseY;
              b.rotation.x = 0;
              b.rotation.z = 0;
            }
          };
          restoreBuildings(this.track.nearBuildings);
          restoreBuildings(this.track.midBuildings);
          restoreBuildings(this.track.farBuildings);
        }

        updateMapBlastVisuals(intensity, time) {
          if (!this.track) return;
          const amount = clamp(intensity, 0, 1);
          if (amount <= 0.0001) {
            this.resetMapBlastVisuals();
            return;
          }

          if (this.track.ground) {
            this.track.ground.rotation.x = -Math.PI * 0.5 + Math.sin(time * 13.5) * 0.032 * amount;
          }
          if (this.track.tieGroup) {
            this.track.tieGroup.position.y = Math.sin(time * 16.8) * 0.16 * amount;
            this.track.tieGroup.rotation.z = Math.sin(time * 8.2) * 0.018 * amount;
          }
          if (this.track.rails) {
            for (let i = 0; i < this.track.rails.length; i++) {
              this.track.rails[i].position.y = 0.05 + Math.sin(time * 14 + i * 0.9) * 0.09 * amount;
            }
          }
          if (this.track.wallSegments) {
            for (let i = 0; i < this.track.wallSegments.length; i++) {
              const seg = this.track.wallSegments[i];
              seg.position.y = Math.sin(time * 9 + i * 0.65) * 0.28 * amount;
              seg.rotation.x = Math.sin(time * 7 + i * 0.35) * 0.03 * amount;
              seg.rotation.z = Math.sin(time * 8.2 + i * 0.41) * 0.028 * amount;
            }
          }

          const wobbleBuildings = (list, yAmp, rotAmp) => {
            if (!list) return;
            for (let i = 0; i < list.length; i++) {
              const b = list[i];
              if (!b.userData) b.userData = {};
              if (b.userData.nukeBaseY === undefined) b.userData.nukeBaseY = b.position.y;
              b.position.y = b.userData.nukeBaseY + Math.sin(time * 6 + i * 0.77) * yAmp * amount;
              b.rotation.z = Math.sin(time * 5.2 + i * 0.6) * rotAmp * amount;
              b.rotation.x = Math.sin(time * 4.8 + i * 0.4) * rotAmp * 0.45 * amount;
            }
          };
          wobbleBuildings(this.track.nearBuildings, 0.34, 0.05);
          wobbleBuildings(this.track.midBuildings, 0.5, 0.06);
          wobbleBuildings(this.track.farBuildings, 0.72, 0.07);
        }

        updateCutscene(dt) {
          this.cutsceneTime += dt;
          if (this.cutsceneSkipRequested) {
            this.cutsceneTime = Math.max(this.cutsceneTime, 2.62);
          }
          const t = this.cutsceneTime;

          this.track.update(dt, 2.4);
          this.player.group.position.set(-2.02, 0, 9.2);
          this.player.group.rotation.y = Math.PI * 0.5;
          this.player.runClock += dt * 2.2;
          this.player.visualRoot.position.y = Math.abs(Math.sin(this.player.runClock * 4)) * 0.03;
          this.player.leftLegPivot.rotation.x = -0.14;
          this.player.rightLegPivot.rotation.x = 0.11;

          const spraySwing = Math.sin(t * 18) * 0.26;
          this.player.rightArmPivot.rotation.x = -1.06 + spraySwing;
          this.player.rightArmPivot.rotation.z = -0.62;
          this.player.leftArmPivot.rotation.x = 0.24;
          this.player.leftArmPivot.rotation.z = -0.16;

          const paintT = clamp((t - 0.2) / 1.55, 0, 1);
          this.cutsceneGraffiti.material.opacity = paintT * 0.95;
          this.cutsceneGraffiti.scale.set(lerp(0.5, 1, paintT), lerp(0.5, 1, paintT), 1);

          this.cutsceneSpray.visible = t < 2.05;
          if (this.cutsceneSpray.visible) {
            this.cutsceneSpray.position.set(
              this.player.group.position.x + 0.34,
              1.19 + Math.sin(t * 17) * 0.07,
              this.player.group.position.z + 0.14
            );
            this.cutsceneSpray.rotation.y = Math.PI * 0.53;
          }

          if (t < 1.75) {
            this.ui.setCutsceneCaption("Spray painting the train...");
            this.chaser.group.position.set(4.8, 0, 8.55);
            this.chaser.group.rotation.y = -Math.PI * 0.55;
          } else if (t < 2.5) {
            const enter = clamp((t - 1.75) / 0.75, 0, 1);
            this.ui.setCutsceneCaption("A cop spots you!");
            this.chaser.animateRun(dt, 1.8);
            this.chaser.group.position.x = lerp(4.8, 0.7, enter);
            this.chaser.group.position.z = lerp(8.55, 8.2, enter);
            this.chaser.group.rotation.y = lerp(-Math.PI * 0.55, -Math.PI * 0.18, enter);
          } else {
            this.ui.setCutsceneCaption("HEY! STOP!");
            this.chaser.animateRun(dt, 1.3);
            this.chaser.group.position.x = lerp(this.chaser.group.position.x, 0.5, Math.min(1, dt * 5));
            this.chaser.group.position.z = lerp(this.chaser.group.position.z, 8.12, Math.min(1, dt * 5));
            this.chaser.group.rotation.y = lerp(this.chaser.group.rotation.y, -0.08, Math.min(1, dt * 5));
            this.chaser.leftArmPivot.rotation.x = -1.15;
            this.chaser.rightArmPivot.rotation.x = -0.9;
          }

          if (t >= 2.5 && !this.cutsceneWhistlePlayed) {
            this.audio.playStartWhistle();
            this.cutsceneWhistlePlayed = true;
          }

          if (t >= 3.22 && !this.cutsceneStartedRun) {
            this.cutsceneStartedRun = true;
            this.startRun(false);
            return;
          }

          const camPan = clamp((t - 1.45) / 1.0, 0, 1);
          // Keep the camera on the spray-paint side of the train (left side).
          const camX = lerp(-4.05, -2.8, camPan);
          const camY = lerp(2.15, 2.45, camPan);
          const camZ = lerp(7.75, 8.45, camPan);
          this.setCameraUprightLookAt(
            camX,
            camY,
            camZ,
            lerp(-1.9, -1.3, camPan),
            1.7,
            lerp(9.65, 9.1, camPan),
            0
          );
        }

        updateCrashSequence(dt, time) {
          this.deathSeqTime += dt;
          const t = this.deathSeqTime;
          const postSpeed = this.speed * 0.24;
          const worldSpeed = t < 1.25 ? postSpeed : 0;
          this.track.update(dt, worldSpeed);
          this.obstacleManager.update(dt, worldSpeed, this.distance);
          this.coinManager.update(dt, worldSpeed, time);
          this.particles.update(dt, worldSpeed);

          const RISE_START = 0.1;
          const RISE_DURATION = 1.08;
          const CUFF_START = 0.92;
          const KICK_START = 1.42;
          const KICK_DURATION = 1.12;
          const KICK_END = KICK_START + KICK_DURATION;
          const IN_CELL_TIME = KICK_END + 0.1;
          const DOOR_CLOSE_START = IN_CELL_TIME + 0.06;
          const DOOR_CLOSE_DURATION = 0.62;
          const DOOR_CLOSE_END = DOOR_CLOSE_START + DOOR_CLOSE_DURATION;
          const DIALOG_START = DOOR_CLOSE_END + 0.08;
          const DIALOG_DURATION = 2.0;
          const DIALOG_END = DIALOG_START + DIALOG_DURATION;
          const LAUNCH_START = DIALOG_END;
          const LAUNCH_ASCENT_END = LAUNCH_START + 1.55;
          const NUKE_DROP_START = LAUNCH_ASCENT_END + 0.15;
          const NUKE_IMPACT_TIME = NUKE_DROP_START + 1.4;
          const CUTSCENE_END = 10.0;
          const guardX = 1.74;
          const guardZ = 16.35;

          const rise = clamp((t - RISE_START) / RISE_DURATION, 0, 1);
          const riseEase = easeOutCubic(rise);
          const risePop = Math.sin(rise * Math.PI) * 0.24 * (1 - rise * 0.4);
          this.jailGroup.visible = true;
          this.jailGroup.position.y = lerp(-5.8, 0, riseEase) + risePop;
          this.jailGroup.position.z = 18.4;
          this.jailGroup.scale.set(
            lerp(0.92, 1, riseEase),
            lerp(0.82, 1.03, riseEase) - Math.max(0, rise - 0.84) * 0.18,
            lerp(0.92, 1, riseEase)
          );
          this.jailGroup.rotation.set(0, 0, 0);

          if (rise > 0.16 && rise < 0.94) {
            this.shakeTime = Math.max(this.shakeTime, 0.08);
            this.shakeAmp = Math.max(this.shakeAmp, 0.09);
          }

          if (this.jailBeaconRedMat && this.jailBeaconBlueMat) {
            const pulse = t * 14;
            const redPulse = Math.max(0.12, Math.sin(pulse) * 0.5 + 0.5);
            const bluePulse = Math.max(0.12, Math.sin(pulse + Math.PI) * 0.5 + 0.5);
            this.jailBeaconRedMat.emissiveIntensity = 0.2 + redPulse * 1.65;
            this.jailBeaconBlueMat.emissiveIntensity = 0.2 + bluePulse * 1.65;
            if (this.jailBeaconRedGlow) this.jailBeaconRedGlow.material.opacity = 0.1 + redPulse * 0.36;
            if (this.jailBeaconBlueGlow) this.jailBeaconBlueGlow.material.opacity = 0.1 + bluePulse * 0.36;
            if (this.jailRedLight) this.jailRedLight.intensity = 0.25 + redPulse * 1.3;
            if (this.jailBlueLight) this.jailBlueLight.intensity = 0.25 + bluePulse * 1.3;
          }

          this.updateMapBlastVisuals(0, t);

          if (this.jailRocketGroup) this.jailRocketGroup.visible = false;
          if (this.jailRocketFlames) {
            for (const flame of this.jailRocketFlames) {
              flame.position.y = flame.userData.basePosY ?? -0.46;
              flame.scale.set(flame.userData.baseX ?? 0.62, flame.userData.baseY ?? 0.86, 1);
              flame.material.opacity = 0.9;
              flame.material.rotation = 0;
            }
          }
          if (this.jailRocketLights) {
            for (const light of this.jailRocketLights) light.intensity = 0;
          }

          if (t >= LAUNCH_START) {
            const launch = clamp((t - LAUNCH_START) / Math.max(0.25, LAUNCH_ASCENT_END - LAUNCH_START), 0, 1);
            const launchEase = launch * launch * launch;
            const rumble = Math.sin((t - LAUNCH_START) * 34) * (1 - launch) * 0.06;
            this.jailGroup.position.y += lerp(0, 21.5, launchEase) + rumble;
            this.jailGroup.position.z += lerp(0, 15.5, launchEase);
            this.jailGroup.rotation.x = -0.12 * (1 - launch);
            this.jailGroup.rotation.z = Math.sin((t - LAUNCH_START) * 16) * 0.012 * (1 - launch);
            if (t > LAUNCH_ASCENT_END) {
              const drift = t - LAUNCH_ASCENT_END;
              this.jailGroup.position.y += drift * 8.2;
              this.jailGroup.position.z += drift * 5.3;
            }

            if (this.jailRocketGroup) this.jailRocketGroup.visible = true;
            if (this.jailRocketFlames) {
              for (let i = 0; i < this.jailRocketFlames.length; i++) {
                const flame = this.jailRocketFlames[i];
                const phase = flame.userData.phase ?? i * 2.7;
                const flicker = 0.9 + Math.sin(t * 41 + phase) * 0.18;
                const baseX = flame.userData.baseX ?? 0.62;
                const baseY = flame.userData.baseY ?? 0.86;
                const basePosY = flame.userData.basePosY ?? -0.46;
                flame.position.y = basePosY - launchEase * 0.16 + Math.sin(t * 30 + phase) * 0.02;
                flame.scale.x = baseX * (1.08 + launchEase * 0.88) * (0.94 + flicker * 0.08);
                flame.scale.y = baseY * (0.62 + launchEase * 3.95) * flicker;
                flame.scale.z = 1;
                flame.material.opacity = 0.62 + launchEase * 0.32 + Math.sin(t * 36 + phase) * 0.06;
                flame.material.rotation = Math.sin(t * 15 + phase) * 0.1;
              }
            }
            if (this.jailRocketLights) {
              for (let i = 0; i < this.jailRocketLights.length; i++) {
                const light = this.jailRocketLights[i];
                light.intensity = 0.6 + launchEase * 3.4 + Math.sin(t * 30 + i * 1.7) * 0.28;
              }
            }

            if (!this.deathRocketIgnited) {
              this.deathRocketIgnited = true;
              this.logEvent("jail-rocket-launch", { t: Number(t.toFixed(2)) });
            }
          }

          if (this.nukeGroup) this.nukeGroup.visible = false;
          if (this.nukeShockwave) {
            this.nukeShockwave.visible = false;
            this.nukeShockwave.material.opacity = 0;
          }
          if (this.nukeFlashLight) this.nukeFlashLight.intensity = 0;

          if (t >= NUKE_DROP_START && t < NUKE_IMPACT_TIME && this.nukeGroup && this.nukeImpactPoint) {
            const drop = clamp((t - NUKE_DROP_START) / Math.max(0.25, NUKE_IMPACT_TIME - NUKE_DROP_START), 0, 1);
            const dropEase = easeInQuad(drop);
            this.nukeGroup.visible = true;
            this.nukeGroup.position.x = lerp(-0.9, this.nukeImpactPoint.x, dropEase);
            this.nukeGroup.position.y = lerp(26, this.nukeImpactPoint.y + 0.35, dropEase);
            this.nukeGroup.position.z = lerp(34, this.nukeImpactPoint.z + 0.08, dropEase);
            this.nukeGroup.rotation.x = Math.PI + drop * 7.2;
            this.nukeGroup.rotation.y = Math.sin(t * 6.4) * 0.16;
            this.nukeGroup.rotation.z = Math.sin(t * 12.4) * 0.08;
            if (!this.deathNukeDropped) {
              this.deathNukeDropped = true;
              this.logEvent("nuke-drop", { t: Number(t.toFixed(2)) });
            }
          }

          if (t >= NUKE_IMPACT_TIME && this.nukeImpactPoint) {
            const blast = clamp((t - NUKE_IMPACT_TIME) / Math.max(0.25, CUTSCENE_END - NUKE_IMPACT_TIME), 0, 1);
            const blastEase = 1 - Math.pow(1 - blast, 2);
            if (!this.deathNukeExploded) {
              this.deathNukeExploded = true;
              this.shakeTime = Math.max(this.shakeTime, 1.6);
              this.shakeAmp = Math.max(this.shakeAmp, 0.72);
              this.ui.flashCrash();
              for (let i = 0; i < 9; i++) {
                const spread = new THREE.Vector3(
                  this.nukeImpactPoint.x + rand(-2.8, 2.8),
                  this.nukeImpactPoint.y + rand(0.1, 1.8),
                  this.nukeImpactPoint.z + rand(-2.2, 2.4)
                );
                this.particles.emitCoinBurst(spread, 18);
              }
              this.logEvent("nuke-impact", { t: Number(t.toFixed(2)) });
            }

            if (this.nukeShockwave) {
              this.nukeShockwave.visible = true;
              this.nukeShockwave.position.copy(this.nukeImpactPoint);
              this.nukeShockwave.position.y = this.nukeImpactPoint.y + blastEase * 0.75;
              const shockScale = lerp(0.35, 31, blastEase);
              this.nukeShockwave.scale.set(shockScale, lerp(0.2, 2.8, blastEase), shockScale);
              this.nukeShockwave.material.opacity = (1 - blast) * 0.58;
            }
            if (this.nukeFlashLight) {
              this.nukeFlashLight.position.copy(this.nukeImpactPoint);
              this.nukeFlashLight.intensity = (1 - blast) * 15 + Math.sin(t * 48) * 0.35 * (1 - blast);
            }
            const mapBlast = Math.max(0, 1 - blast * 0.85);
            this.updateMapBlastVisuals(mapBlast, t);
            if (blast < 0.3 && Math.floor((t - NUKE_IMPACT_TIME) * 20) % 4 === 0) {
              this.particles.emitCoinBurst(
                new THREE.Vector3(
                  this.nukeImpactPoint.x + rand(-1.7, 1.7),
                  this.nukeImpactPoint.y + rand(0.2, 1.6),
                  this.nukeImpactPoint.z + rand(-1.6, 1.6)
                ),
                8
              );
            }
          }

          const inCellBaseY = this.jailGroup.position.y + 0.02;
          const inCellBaseZ = this.jailGroup.position.z - 0.92;

          if (t < DOOR_CLOSE_START) {
            this.jailDoor.position.x = -1.05;
          } else {
            const close = clamp((t - DOOR_CLOSE_START) / DOOR_CLOSE_DURATION, 0, 1);
            const closeEase = easeOutCubic(close);
            const bounce = Math.sin(close * Math.PI) * 0.08 * (1 - close);
            this.jailDoor.position.x = lerp(-1.05, 0, closeEase) + bounce;
            if (close >= 1 && !this.deathDoorSlammed) {
              this.deathDoorSlammed = true;
              this.shakeTime = Math.max(this.shakeTime, 0.24);
              this.shakeAmp = Math.max(this.shakeAmp, 0.2);
              this.logEvent("jail-door-slam", { t: Number(t.toFixed(2)) });
            }
          }

          this.chaser.setVisible(true);
          if (t < DOOR_CLOSE_START) {
            this.chaser.animateRun(dt, 1.78);
            const chaseTargetZ = this.player.group.position.z - 0.94;
            this.chaser.group.position.x = lerp(
              this.chaser.group.position.x,
              this.player.group.position.x + 0.46,
              Math.min(1, dt * 6.2)
            );
            this.chaser.group.position.z = lerp(this.chaser.group.position.z, chaseTargetZ, Math.min(1, dt * 5.6));
            this.chaser.group.rotation.y = lerp(this.chaser.group.rotation.y, -0.1, Math.min(1, dt * 5.4));
          } else {
            const guardIdle = Math.sin((t - DOOR_CLOSE_START) * 3.3) * 0.03;
            this.chaser.group.position.x = lerp(this.chaser.group.position.x, guardX, Math.min(1, dt * 6));
            this.chaser.group.position.z = lerp(this.chaser.group.position.z, guardZ, Math.min(1, dt * 6));
            this.chaser.group.position.y = guardIdle;
            this.chaser.group.rotation.y = lerp(this.chaser.group.rotation.y, -0.74, Math.min(1, dt * 7));
            this.chaser.leftArmPivot.rotation.x = -0.4 + guardIdle * 0.7;
            this.chaser.rightArmPivot.rotation.x = -0.3 + guardIdle * 0.7;
            this.chaser.leftArmPivot.rotation.z = 0;
            this.chaser.rightArmPivot.rotation.z = 0;
            this.chaser.leftLegPivot.rotation.x = guardIdle * 0.4;
            this.chaser.rightLegPivot.rotation.x = -guardIdle * 0.4;
            this.chaser.leftShinPivot.rotation.x = 0;
            this.chaser.rightShinPivot.rotation.x = 0;
          }

          if (t < 0.86) {
            this.player.update(dt, postSpeed, false);
          } else if (t < KICK_START) {
            const stumble = Math.sin((t - 0.86) * 11) * 0.03;
            this.player.group.position.z = 0;
            this.player.group.position.y = Math.abs(stumble);
            this.player.visualRoot.rotation.x = lerp(this.player.visualRoot.rotation.x, -0.56, Math.min(1, dt * 8));
            this.player.visualRoot.rotation.z = lerp(this.player.visualRoot.rotation.z, 0.18, Math.min(1, dt * 8));
            this.player.visualRoot.position.y = lerp(this.player.visualRoot.position.y, 0.08, Math.min(1, dt * 8));
          }

          if (t >= CUFF_START && t < IN_CELL_TIME) {
            this.deathCuffed = true;
            this.handcuffs.visible = true;
            this.handcuffs.position.set(
              this.player.group.position.x + 0.05,
              this.player.group.position.y + 1.03 + Math.sin(t * 9) * 0.02,
              this.player.group.position.z + 0.05
            );
            this.handcuffs.rotation.y = Math.PI * 0.16;
            this.chaser.leftArmPivot.rotation.x = -1.25;
            this.chaser.rightArmPivot.rotation.x = -1.1;
          }

          if (t >= KICK_START && t < IN_CELL_TIME) {
            if (!this.deathKickStarted) {
              this.deathKickStarted = true;
              this.deathKickStartX = this.player.group.position.x;
              this.deathKickStartZ = this.player.group.position.z;
            }
            const k = clamp((t - KICK_START) / KICK_DURATION, 0, 1);
            const ke = easeOutCubic(k);
            const targetZ = inCellBaseZ - 0.16;
            this.player.group.position.x = lerp(this.deathKickStartX, 0, ke);
            this.player.group.position.z = lerp(this.deathKickStartZ, targetZ, ke);
            this.player.group.position.y = Math.sin(Math.PI * k) * 1.85 + Math.sin(k * 18) * 0.05;
            this.player.visualRoot.rotation.x = lerp(this.player.visualRoot.rotation.x, -1.24, Math.min(1, dt * 8));
            this.player.visualRoot.rotation.z += dt * (5.8 + k * 2.2);
            this.handcuffs.position.set(
              this.player.group.position.x + 0.05,
              this.player.group.position.y + 1.0,
              this.player.group.position.z + 0.03
            );

            this.chaser.rightLegPivot.rotation.x = -1.0;
            this.chaser.leftLegPivot.rotation.x = 0.34;

            if (k > 0.97 && !this.deathCellImpactDone) {
              this.deathCellImpactDone = true;
              this.shakeTime = Math.max(this.shakeTime, 0.26);
              this.shakeAmp = Math.max(this.shakeAmp, 0.21);
              this.particles.emitCoinBurst(new THREE.Vector3(0, 0.32, inCellBaseZ - 0.12), 22);
              this.logEvent("jail-cell-impact", { t: Number(t.toFixed(2)) });
            }
          }

          if (t >= IN_CELL_TIME) {
            this.player.group.position.set(0, inCellBaseY, inCellBaseZ);
            this.player.visualRoot.rotation.x = -0.24;
            this.player.visualRoot.rotation.z = 0;
            this.player.visualRoot.position.y = 0.03;
            this.player.leftLegPivot.rotation.x = 0.06;
            this.player.rightLegPivot.rotation.x = -0.06;
            this.player.leftShinPivot.rotation.x = 0.1;
            this.player.rightShinPivot.rotation.x = 0.1;
            this.player.leftArmPivot.rotation.x = -0.92;
            this.player.rightArmPivot.rotation.x = -0.92;
            this.player.leftArmPivot.rotation.y = 0;
            this.player.rightArmPivot.rotation.y = 0;
            this.player.leftArmPivot.rotation.z = -0.1;
            this.player.rightArmPivot.rotation.z = 0.1;
            this.handcuffs.visible = false;
          }

          if (t >= DIALOG_START && t < DIALOG_END) {
            const pullPhase = (t - DIALOG_START) * 6.6;
            const pull = Math.sin(pullPhase);
            const forward = Math.max(0, pull) * 0.19;
            const backward = Math.max(0, -pull) * 0.1;
            const reach = Math.max(0, pull);
            const popT = clamp((t - DIALOG_START) / 0.3, 0, 1);
            const pop = 0.86 + easeOutCubic(popT) * 0.17;

            this.player.group.position.z = inCellBaseZ - forward + backward;
            this.player.group.position.y = inCellBaseY + Math.abs(Math.sin(pullPhase * 0.5)) * 0.04;
            this.player.visualRoot.rotation.x = -0.3 + reach * 0.24;
            this.player.visualRoot.position.y = 0.03 + reach * 0.1;
            this.player.leftArmPivot.rotation.x = -1.62 + reach * 0.28;
            this.player.rightArmPivot.rotation.x = -1.62 + reach * 0.28;
            this.player.leftArmPivot.rotation.y = -0.24;
            this.player.rightArmPivot.rotation.y = 0.24;
            this.player.leftArmPivot.rotation.z = -0.03;
            this.player.rightArmPivot.rotation.z = 0.03;

            this.copSpeechBubble.visible = true;
            this.playerSpeechBubble.visible = true;
            this.copSpeechBubble.scale.set(4.18 * pop, 1.26 * pop, 1);
            this.playerSpeechBubble.scale.set(4.32 * pop, 1.58 * pop, 1);
            const copBubbleX = clamp(this.chaser.group.position.x - 0.42, 0.55, 1.25);
            const playerBubbleX = clamp(this.player.group.position.x - 0.66, -1.15, -0.3);
            this.copSpeechBubble.position.set(
              copBubbleX,
              this.chaser.group.position.y + 3.2,
              this.chaser.group.position.z + 0.56
            );
            this.playerSpeechBubble.position.set(
              playerBubbleX,
              this.player.group.position.y + 3.2,
              this.player.group.position.z - 0.22
            );
          } else {
            this.copSpeechBubble.visible = false;
            this.playerSpeechBubble.visible = false;
          }

          this.crashTimer -= dt;
          if (t >= CUTSCENE_END || this.crashTimer <= 0) {
            this.handcuffs.visible = false;
            this.copSpeechBubble.visible = false;
            this.playerSpeechBubble.visible = false;
            this.finishRun();
          }
        }

        updateCamera(dt) {
          if (this.state === "cutscene") return;
          if (this.state === "crashed") {
            const seqT = this.deathSeqTime;
            let camX;
            let camY;
            let camZ;
            let targetX;
            let targetY;
            let targetZ;
            let roll = 0;
            const ROCKET_LAUNCH_START = 5.4;
            const NUKE_DROP_START = 7.1;
            const NUKE_IMPACT_TIME = 8.5;
            const CRASH_CUTSCENE_END = 10.0;

            if (seqT < 1.35) {
              const p = clamp(seqT / 1.35, 0, 1);
              camX = lerp(this.player.group.position.x * 0.25, -0.65, p);
              camY = lerp(7.2, 5.4, p);
              camZ = lerp(-11.2, -5.3, p);
              targetX = lerp(this.player.group.position.x * 0.16, -0.08, p);
              targetY = lerp(1.9, 1.58, p);
              targetZ = lerp(8.0, this.player.group.position.z + 2.4, p);
            } else if (seqT < 2.9) {
              const p = clamp((seqT - 1.35) / 1.55, 0, 1);
              camX = lerp(-0.65, 2.0, p);
              camY = lerp(5.4, 4.65, p);
              camZ = lerp(-5.3, 1.65, p);
              targetX = lerp(-0.08, 0.2, p);
              targetY = lerp(1.58, 1.5, p);
              targetZ = lerp(this.player.group.position.z + 2.4, this.jailGroup.position.z - 0.85, p);
            } else if (seqT < ROCKET_LAUNCH_START) {
              const p = clamp((seqT - 2.9) / (ROCKET_LAUNCH_START - 2.9), 0, 1);
              const orbit = Math.sin((seqT - 2.9) * 1.8) * 0.42;
              camX = lerp(2.0, 0.28, p) + orbit;
              camY = lerp(4.65, 4.05, p);
              camZ = lerp(1.65, 6.25, p);
              targetX = lerp(0.2, 0, p);
              targetY = lerp(1.5, 1.42, p);
              targetZ = this.jailGroup.position.z - 0.82;
              roll = orbit * -0.03;
            } else if (seqT < NUKE_DROP_START) {
              const p = clamp((seqT - ROCKET_LAUNCH_START) / (NUKE_DROP_START - ROCKET_LAUNCH_START), 0, 1);
              const rumble = Math.sin((seqT - ROCKET_LAUNCH_START) * 22) * (1 - p);
              camX = lerp(0.28, -0.22, p) + rumble * 0.1;
              camY = lerp(4.05, 5.2, p);
              camZ = lerp(6.25, 11.1, p);
              targetX = lerp(0, 0.12, p);
              targetY = lerp(1.42, 5.6, p);
              targetZ = lerp(this.jailGroup.position.z - 0.82, this.jailGroup.position.z + 4.6, p);
              roll = rumble * -0.03;
            } else if (seqT < NUKE_IMPACT_TIME) {
              const p = clamp((seqT - NUKE_DROP_START) / (NUKE_IMPACT_TIME - NUKE_DROP_START), 0, 1);
              const nukePos = this.nukeGroup && this.nukeGroup.visible
                ? this.nukeGroup.position
                : (this.nukeImpactPoint || new THREE.Vector3(0, 0.5, 16.2));
              camX = lerp(-2.6, -0.35, p);
              camY = lerp(9.2, 6.0, p);
              camZ = lerp(14.8, 8.5, p);
              targetX = lerp(-0.4, nukePos.x, p);
              targetY = lerp(6.4, Math.max(0.5, nukePos.y), p);
              targetZ = lerp(20.8, nukePos.z, p);
              roll = Math.sin(seqT * 9.4) * 0.02 * (1 - p);
            } else {
              const p = clamp((seqT - NUKE_IMPACT_TIME) / (CRASH_CUTSCENE_END - NUKE_IMPACT_TIME), 0, 1);
              const blastShake = (1 - p);
              const rumble = Math.sin((seqT - NUKE_IMPACT_TIME) * 30) * blastShake;
              const impact = this.nukeImpactPoint || new THREE.Vector3(0, 0.5, 16.2);
              camX = lerp(-0.35, -1.9, p) + rumble * 0.12;
              camY = lerp(6.0, 10.8, p) + Math.abs(rumble) * 0.18;
              camZ = lerp(8.5, -2.2, p);
              targetX = lerp(impact.x, 0, p);
              targetY = lerp(impact.y + 0.9, 2.2, p);
              targetZ = lerp(impact.z + 0.3, 18.5, p);
              roll = rumble * -0.04;
            }

            this.setCameraUprightLookAt(camX, camY, camZ, targetX, targetY, targetZ, roll);
            return;
          }
          this.cameraDip = Math.max(0, this.cameraDip - dt * 2.5);
          const useCopCam = this.state === "playing" && this.playMode === "cop";
          const actorPos = useCopCam ? this.chaser.group.position : this.player.group.position;
          const actorJump = useCopCam ? this.chaser.jumpY : this.player.jumpY;
          const actorLean = useCopCam ? this.chaser.laneLean : this.player.laneLean;
          const targetX = actorPos.x * 0.35;
          this.cameraX = lerp(this.cameraX, targetX, Math.min(1, dt * 8));

          let shakeX = 0;
          let shakeY = 0;
          let shakeZ = 0;
          if (this.shakeTime > 0) {
            this.shakeTime = Math.max(0, this.shakeTime - dt);
            const amp = this.shakeAmp * (this.shakeTime / 0.35);
            shakeX = rand(-amp, amp);
            shakeY = rand(-amp, amp) * 0.7;
            shakeZ = rand(-amp * 0.7, amp * 0.7);
          }

          this.setCameraUprightLookAt(
            this.cameraX + shakeX,
            8 + this.cameraDip + shakeY,
            -12 + shakeZ,
            actorPos.x * 0.16,
            2 + actorJump * 0.13,
            useCopCam ? 20 + this.fugitiveLead * 0.18 : 20,
            actorLean * -0.22
          );

          let fovTarget = 65;
          if (this.state === "playing") {
            const speedBase = Math.max(0, this.speed - CONFIG.baseSpeed);
            fovTarget += speedBase * 0.26;
            if (this.playMode === "runner" && this.activeRunnerPowerUps.hoverboard > 0) fovTarget += 2.4;
            if (this.playMode === "cop" && this.copBoostTimer > 0) fovTarget += 2.0;
          }
          fovTarget = clamp(fovTarget, 65, 74);
          this.camera.fov = lerp(this.camera.fov, fovTarget, Math.min(1, dt * 4.5));
          this.camera.updateProjectionMatrix();
        }

        checkCoinCollisions() {
          const usingCop = this.playMode === "cop";
          const playerPos = usingCop ? this.chaser.group.position : this.player.group.position;
          const playerY = (usingCop ? this.chaser.jumpY : this.player.jumpY) + 0.9;
          const pickupRadius = usingCop ? 1.0 : this.getRunnerCoinPickupRadius();
          const pickupRadiusSq = pickupRadius * pickupRadius;
          const strictAutoLanePickup = !usingCop && this.autoRunnerActive && this.activeRunnerPowerUps.magnet <= 0;
          for (let i = this.coinManager.active.length - 1; i >= 0; i--) {
            const c = this.coinManager.active[i];
            const dx = c.mesh.position.x - playerPos.x;
            if (strictAutoLanePickup && Math.abs(dx) > 0.95) continue;
            const dy = c.mesh.position.y - playerY;
            const dz = c.z;
            const distSq = dx * dx + dy * dy + dz * dz;
            if (distSq < pickupRadiusSq) {
              const coin = this.coinManager.removeAt(i);
              if (coin) {
                this.runCoins += 1;
                this.score += 25;
                this.particles.emitCoinBurst(coin.mesh.position, 9);
                this.audio.play("coinCollect");
              }
            }
          }
        }

        applyRunnerTrainRampSupport() {
          if (this.state !== "playing" || this.playMode !== "runner") return;

          const px = this.player.group.position.x;
          let supportY = 0;
          let roofSupport = false;
          for (const o of this.obstacleManager.active) {
            if (o.airborne || !o.collidable) continue;
            if (o.type !== "TRAIN" && o.type !== "TRAIN_MOVING") continue;

            const xOverlap = Math.abs(px - o.x) * 2 < (o.w + 0.88);
            if (!xOverlap) continue;

            const front = o.z - o.d * 0.5;
            const back = o.z + o.d * 0.5;
            const topY = o.y + o.h * 0.5 + 0.04;

            if (o.hasRamp) {
              const rampDepth = o.rampDepth || 3.4;
              const rampStart = front - rampDepth;
              if (rampStart <= 0 && front >= 0) {
                const t = clamp((0 - rampStart) / rampDepth, 0, 1);
                supportY = Math.max(supportY, topY * easeOutQuad(t));
              }
            }

            if (front <= 0 && back >= 0) {
              supportY = Math.max(supportY, topY);
              roofSupport = true;
            }
          }

          if (supportY > 0) {
            if (roofSupport) this.wasOnTrainTop = true;
            this.player.isJumping = false;
            this.player.jumpY = Math.max(this.player.jumpY, supportY);
            return;
          }

          if (this.player.isJumping) {
            this.wasOnTrainTop = false;
            return;
          }

          if (this.wasOnTrainTop && this.player.jumpY > 0.28) {
            this.wasOnTrainTop = false;
            this.crash();
            return;
          }

          if (this.player.jumpY <= 0.02) {
            this.wasOnTrainTop = false;
          }
        }

        tryAbsorbRunnerCollision(index, obstacle) {
          if (this.playMode !== "runner") return false;
          if (this.activeRunnerPowerUps.hoverboard > 0) {
            this.activeRunnerPowerUps.hoverboard = 0;
            this.logEvent("collision-absorbed", { source: "hoverboard", obstacle: obstacle?.type || "unknown" });
          } else if (this.shieldCharges > 0) {
            this.shieldCharges -= 1;
            this.logEvent("collision-absorbed", { source: "shield", remainingShields: this.shieldCharges, obstacle: obstacle?.type || "unknown" });
          } else {
            return false;
          }
          this.shakeTime = 0.22;
          this.shakeAmp = 0.14;
          this.ui.flashCrash();
          if (obstacle && obstacle.mesh) this.particles.emitCoinBurst(obstacle.mesh.position, 12);
          if (index >= 0) {
            this.obstacleManager.release(obstacle);
            this.obstacleManager.active.splice(index, 1);
          }
          return true;
        }

        checkObstacleCollisions() {
          if (this.isAutoFunGodMode()) return;
          const playerBox = this.playMode === "cop" ? this.chaser.getHitbox() : this.player.getHitbox();
          for (let i = 0; i < this.obstacleManager.active.length; i++) {
            const o = this.obstacleManager.active[i];
            if (o.airborne || !o.collidable) continue;
            const obstacleBox = {
              x: o.x,
              y: o.y,
              z: o.z,
              w: o.w,
              h: o.h,
              d: o.d
            };

            if (o.kind === "full_block") {
              const xOverlap = Math.abs(playerBox.x - obstacleBox.x) * 2 < (playerBox.w + obstacleBox.w);
              const zOverlap = Math.abs(playerBox.z - obstacleBox.z) * 2 < (playerBox.d + obstacleBox.d);
              if (xOverlap && zOverlap) {
                const obstacleTop = obstacleBox.y + obstacleBox.h * 0.5;
                const playerBottom = playerBox.y - playerBox.h * 0.5;
                if (playerBottom >= obstacleTop - 0.06) continue;
                if (this.tryAbsorbRunnerCollision(i, o)) return;
                this.crash();
                return;
              }
              continue;
            }

            if (intersectsAABB(playerBox, obstacleBox)) {
              if (this.tryAbsorbRunnerCollision(i, o)) return;
              this.crash();
              return;
            }
          }
        }

        updateCopMode(dt, time) {
          this.speed = Math.min(CONFIG.maxSpeed, this.speed + CONFIG.acceleration * dt * 0.9);
          const speedMult = this.getGlobalSpeedMultiplier();

          if (this.copBoostTimer > 0) this.copBoostTimer = Math.max(0, this.copBoostTimer - dt);
          if (this.fugitiveBurstTimer > 0) {
            this.fugitiveBurstTimer = Math.max(0, this.fugitiveBurstTimer - dt);
            if (this.fugitiveBurstTimer <= 0) this.fugitiveSpeedBonus = 0;
          } else {
            this.nextFugitiveBurst -= dt;
            if (this.nextFugitiveBurst <= 0) {
              this.fugitiveBurstTimer = rand(1.8, 3.0);
              this.fugitiveSpeedBonus = rand(2.8, 4.8);
              this.fugitiveLead += rand(1.1, 2.0);
              this.nextFugitiveBurst = rand(6.0, 10.5);
            }
          }

          const copSpeed = (this.speed + (this.copBoostTimer > 0 ? 5.2 : 0)) * speedMult;
          const fugitiveSpeed = (this.speed + this.fugitiveSpeedBonus) * speedMult;
          this.fugitiveLead += (fugitiveSpeed - copSpeed) * dt;
          this.fugitiveLead = clamp(this.fugitiveLead, 1.0, 24.0);

          this.distance += copSpeed * dt;
          const pressureBonus = Math.max(0, 14 - this.fugitiveLead) * 9;
          this.score = Math.floor(this.distance * 4.4 + this.runCoins * 25 + pressureBonus);

          this.track.update(dt, copSpeed);
          this.chaser.updateControlled(dt, copSpeed);
          this.obstacleManager.update(dt, copSpeed, this.distance);
          this.coinManager.update(dt, copSpeed, time);
          this.updateCopBoosts(dt, copSpeed, time);
          this.particles.update(dt, copSpeed);

          this.updateFugitiveAI(dt);
          this.player.update(dt, fugitiveSpeed, false);
          this.player.group.position.z = this.fugitiveLead;
          this.player.group.rotation.y = 0;

          this.checkCoinCollisions();
          this.checkCopBoostCollisions();
          this.checkObstacleCollisions();

          if (this.state !== "playing") return;

          if (
            this.fugitiveLead <= 1.18 &&
            Math.abs(this.chaser.group.position.x - this.player.group.position.x) < 0.9 &&
            Math.abs(this.chaser.jumpY - this.player.jumpY) < 1.2
          ) {
            this.isCopOutcome = true;
            this.copCaughtRunner = true;
            this.finishRun("You Caught Him!");
            return;
          }

          this.chaser.setVisible(true);
          this.ui.updateHUD(this.score, this.runCoins, this.distance);
          if (this.copBoostTimer > 0) {
            this.ui.multiplier.textContent = "BOOST!";
          } else if (this.fugitiveBurstTimer > 0) {
            this.ui.multiplier.textContent = "HE'S FAST!";
          } else {
            this.ui.multiplier.textContent = `GAP ${this.fugitiveLead.toFixed(1)}m`;
          }
          this.ui.pulseMultiplier(true);
          this.updateRuntimeTelemetry(dt, copSpeed);
        }

        updatePlaying(dt, time) {
          if (this.state === "cutscene") {
            this.chaser.setVisible(true);
            this.updateCutscene(dt);
            this.particles.update(dt, 0);
          } else if (this.state === "playing") {
            if (this.playMode === "cop") {
              this.updateCopMode(dt, time);
            } else {
              const ability = this.characterAbility || buildAbilityFromPrice(0);
              this.updateRunnerPowerUpTimers(dt);
              const hoverboardSpeed = this.activeRunnerPowerUps.hoverboard > 0 ? 2.2 : 0;
              const scoreMult = ability.scoreMultiplier + (this.activeRunnerPowerUps.hoverboard > 0 ? 0.12 : 0);
              this.player.setAbilityModifiers({ jumpScale: this.getRunnerJumpScale() });
              if (this.autoRunnerActive) {
                const inputMult = this.getAutoRunnerInputMultiplier();
                this.player.laneSwitchDuration = clamp(0.04 / Math.max(1, Math.sqrt(inputMult)), 0.005, CONFIG.laneSwitchDuration);
              } else {
                this.player.laneSwitchDuration = CONFIG.laneSwitchDuration;
              }
              this.speed = Math.min(CONFIG.maxSpeed, this.speed + CONFIG.acceleration * dt);
              const runnerSpeed = (this.speed + ability.speedBonus + hoverboardSpeed) * this.getRunnerSpeedMultiplier();
              this.distance += runnerSpeed * dt;
              this.score = Math.floor((this.distance * 4 + this.runCoins * 25) * scoreMult);

              this.updateAutoRunner(dt);
              this.track.update(dt, runnerSpeed);
              this.player.update(dt, runnerSpeed, false);
              this.obstacleManager.update(dt, runnerSpeed, this.distance);
              this.coinManager.update(dt, runnerSpeed, time);
              this.updateRunnerPowerUps(dt, runnerSpeed, time);
              this.applyRunnerTrainRampSupport();
              if (this.state !== "playing") return;
              this.particles.update(dt, runnerSpeed);

              this.checkCoinCollisions();
              this.checkRunnerPowerUpCollisions();
              this.checkObstacleCollisions();
              if (this.state !== "playing") return;
              this.ui.updateHUD(this.score, this.runCoins, this.distance);
              const statuses = [];
              if (this.activeRunnerPowerUps.hoverboard > 0) statuses.push(`BOARD ${Math.ceil(this.activeRunnerPowerUps.hoverboard)}`);
              if (this.activeRunnerPowerUps.magnet > 0) statuses.push(`MAG ${Math.ceil(this.activeRunnerPowerUps.magnet)}`);
              if (this.activeRunnerPowerUps.sneakers > 0) statuses.push(`JUMP ${Math.ceil(this.activeRunnerPowerUps.sneakers)}`);
              if (this.shieldCharges > 0) statuses.push(`SHIELD ${this.shieldCharges}`);
              if (this.autoRunnerActive) statuses.push("AUTO");
              if (this.shieldCharges > 0) {
                this.ui.multiplier.textContent = `x${scoreMult.toFixed(2)} ${statuses.join(" ")}`;
              } else {
                this.ui.multiplier.textContent = statuses.length > 0 ? `x${scoreMult.toFixed(2)} ${statuses.join(" ")}` : `x${scoreMult.toFixed(2)}`;
              }
              this.ui.pulseMultiplier(this.distance > 700 || statuses.length > 0);
              this.chaser.setVisible(true);
              this.chaser.updateGameplay(dt, this.player.group.position.x, runnerSpeed, "playing", this.obstacleManager.active);
              this.updateRuntimeTelemetry(dt, runnerSpeed);
            }
          } else if (this.state === "crashed") {
            this.updateCrashSequence(dt, time);
          } else if (this.state === "menu") {
            const menuSpeed = 8;
            this.track.update(dt, menuSpeed);
            this.player.update(dt, menuSpeed, true);
            this.particles.update(dt, 0);
            this.chaser.setVisible(false);
          } else if (this.state === "paused") {
            this.particles.update(dt, 0);
            this.chaser.setVisible(true);
            if (this.playMode === "cop") {
              this.player.update(dt * 0.2, this.speed * 0.16, true);
              this.player.group.position.z = this.fugitiveLead;
              this.chaser.updateControlled(dt * 0.2, this.speed * 0.16);
              this.chaser.group.position.z = 0;
            } else {
              this.player.update(dt * 0.25, this.speed * 0.2, true);
              this.chaser.updateGameplay(dt * 0.3, this.player.group.position.x, this.speed * 0.25, "playing", null);
            }
          } else if (this.state === "gameover") {
            this.player.update(dt * 0.2, 3, true);
            this.chaser.setVisible(false);
          }
        }

        loop(timeMs) {
          if (!this.lastTime) this.lastTime = timeMs;
          const dt = Math.min(0.05, (timeMs - this.lastTime) / 1000);
          this.lastTime = timeMs;
          const t = timeMs * 0.001;

          this.processInputs();
          this.updatePlaying(dt, t);
          this.updateCamera(dt);
          this.renderer.render(this.scene, this.camera);
          requestAnimationFrame((t2) => this.loop(t2));
        }
      }

      // ===== SECTION 12: INITIALIZATION =====
      window.addEventListener("load", () => {
        const root = document.getElementById("game-root");
        new SubwayRunnerGame(root);
      });
    })();
  </script>
</body>
</html>
